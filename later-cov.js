/**
* Later.js 0.1.0
* (c) 2013 Bill, BunKat LLC.
* Later is freely distributable under the MIT license.
* For all details and documentation:
*     http://bunkat.github.com/later
*/
later = (function() {
  var later = {version: "0.1.0"}; // semver
/* automatically generated by JSCoverage - do not edit */
try {
  if (typeof top === 'object' && top !== null && typeof top.opener === 'object' && top.opener !== null) {
    // this is a browser window that was opened from another window

    if (! top.opener._$jscoverage) {
      top.opener._$jscoverage = {};
    }
  }
}
catch (e) {}

try {
  if (typeof top === 'object' && top !== null) {
    // this is a browser window

    try {
      if (typeof top.opener === 'object' && top.opener !== null && top.opener._$jscoverage) {
        top._$jscoverage = top.opener._$jscoverage;
      }
    }
    catch (e) {}

    if (! top._$jscoverage) {
      top._$jscoverage = {};
    }
  }
}
catch (e) {}

try {
  if (typeof top === 'object' && top !== null && top._$jscoverage) {
    _$jscoverage = top._$jscoverage;
  }
}
catch (e) {}
if (typeof _$jscoverage !== 'object') {
  _$jscoverage = {};
}
if (! _$jscoverage['compat/indexof.js']) {
  _$jscoverage['compat/indexof.js'] = [];
  _$jscoverage['compat/indexof.js'][6] = 0;
  _$jscoverage['compat/indexof.js'][7] = 0;
  _$jscoverage['compat/indexof.js'][8] = 0;
  _$jscoverage['compat/indexof.js'][9] = 0;
  _$jscoverage['compat/indexof.js'][10] = 0;
  _$jscoverage['compat/indexof.js'][12] = 0;
  _$jscoverage['compat/indexof.js'][13] = 0;
  _$jscoverage['compat/indexof.js'][14] = 0;
  _$jscoverage['compat/indexof.js'][15] = 0;
  _$jscoverage['compat/indexof.js'][17] = 0;
  _$jscoverage['compat/indexof.js'][18] = 0;
  _$jscoverage['compat/indexof.js'][19] = 0;
  _$jscoverage['compat/indexof.js'][20] = 0;
  _$jscoverage['compat/indexof.js'][21] = 0;
  _$jscoverage['compat/indexof.js'][22] = 0;
  _$jscoverage['compat/indexof.js'][23] = 0;
  _$jscoverage['compat/indexof.js'][26] = 0;
  _$jscoverage['compat/indexof.js'][27] = 0;
  _$jscoverage['compat/indexof.js'][29] = 0;
  _$jscoverage['compat/indexof.js'][30] = 0;
  _$jscoverage['compat/indexof.js'][31] = 0;
  _$jscoverage['compat/indexof.js'][32] = 0;
  _$jscoverage['compat/indexof.js'][35] = 0;
}
_$jscoverage['compat/indexof.js'].source = ["// indexOf compares searchElement to elements of the Array using strict","// equality (the same method used by the ===, or triple-equals, operator).","//","// https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/Array/indexOf","//","if (!Array.prototype.indexOf) {","    Array.prototype.indexOf = function (searchElement /*, fromIndex */ ) {","        \"use strict\";","        if (this == null) {","            throw new TypeError();","        }","        var t = Object(this);","        var len = t.length &gt;&gt;&gt; 0;","        if (len === 0) {","            return -1;","        }","        var n = 0;","        if (arguments.length &gt; 1) {","            n = Number(arguments[1]);","            if (n != n) { // shortcut for verifying if it's NaN","                n = 0;","            } else if (n != 0 &amp;&amp; n != Infinity &amp;&amp; n != -Infinity) {","                n = (n &gt; 0 || -1) * Math.floor(Math.abs(n));","            }","        }","        if (n &gt;= len) {","            return -1;","        }","        var k = n &gt;= 0 ? n : Math.max(len - Math.abs(n), 0);","        for (; k &lt; len; k++) {","            if (k in t &amp;&amp; t[k] === searchElement) {","                return k;","            }","        }","        return -1;","    }","}"];
_$jscoverage['compat/indexof.js'][6]++;
if ((! Array.prototype.indexOf)) {
  _$jscoverage['compat/indexof.js'][7]++;
  Array.prototype.indexOf = (function (searchElement) {
  _$jscoverage['compat/indexof.js'][8]++;
  "use strict";
  _$jscoverage['compat/indexof.js'][9]++;
  if ((this == null)) {
    _$jscoverage['compat/indexof.js'][10]++;
    throw new TypeError();
  }
  _$jscoverage['compat/indexof.js'][12]++;
  var t = Object(this);
  _$jscoverage['compat/indexof.js'][13]++;
  var len = (t.length >>> 0);
  _$jscoverage['compat/indexof.js'][14]++;
  if ((len === 0)) {
    _$jscoverage['compat/indexof.js'][15]++;
    return -1;
  }
  _$jscoverage['compat/indexof.js'][17]++;
  var n = 0;
  _$jscoverage['compat/indexof.js'][18]++;
  if ((arguments.length > 1)) {
    _$jscoverage['compat/indexof.js'][19]++;
    n = Number(arguments[1]);
    _$jscoverage['compat/indexof.js'][20]++;
    if ((n != n)) {
      _$jscoverage['compat/indexof.js'][21]++;
      n = 0;
    }
    else {
      _$jscoverage['compat/indexof.js'][22]++;
      if (((n != 0) && (n != Infinity) && (n != (- Infinity)))) {
        _$jscoverage['compat/indexof.js'][23]++;
        n = (((n > 0) || -1) * Math.floor(Math.abs(n)));
      }
    }
  }
  _$jscoverage['compat/indexof.js'][26]++;
  if ((n >= len)) {
    _$jscoverage['compat/indexof.js'][27]++;
    return -1;
  }
  _$jscoverage['compat/indexof.js'][29]++;
  var k = ((n >= 0)? n: Math.max((len - Math.abs(n)), 0));
  _$jscoverage['compat/indexof.js'][30]++;
  for (; (k < len); (k++)) {
    _$jscoverage['compat/indexof.js'][31]++;
    if (((k in t) && (t[k] === searchElement))) {
      _$jscoverage['compat/indexof.js'][32]++;
      return k;
    }
}
  _$jscoverage['compat/indexof.js'][35]++;
  return -1;
});
}
/* automatically generated by JSCoverage - do not edit */
try {
  if (typeof top === 'object' && top !== null && typeof top.opener === 'object' && top.opener !== null) {
    // this is a browser window that was opened from another window

    if (! top.opener._$jscoverage) {
      top.opener._$jscoverage = {};
    }
  }
}
catch (e) {}

try {
  if (typeof top === 'object' && top !== null) {
    // this is a browser window

    try {
      if (typeof top.opener === 'object' && top.opener !== null && top.opener._$jscoverage) {
        top._$jscoverage = top.opener._$jscoverage;
      }
    }
    catch (e) {}

    if (! top._$jscoverage) {
      top._$jscoverage = {};
    }
  }
}
catch (e) {}

try {
  if (typeof top === 'object' && top !== null && top._$jscoverage) {
    _$jscoverage = top._$jscoverage;
  }
}
catch (e) {}
if (typeof _$jscoverage !== 'object') {
  _$jscoverage = {};
}
if (! _$jscoverage['compat/trim.js']) {
  _$jscoverage['compat/trim.js'] = [];
  _$jscoverage['compat/trim.js'][6] = 0;
  _$jscoverage['compat/trim.js'][7] = 0;
  _$jscoverage['compat/trim.js'][8] = 0;
}
_$jscoverage['compat/trim.js'].source = ["// The trim method returns the string stripped of whitespace from both ends.","// trim does not affect the value of the string itself.","//","// https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/String/Trim","//","if(!String.prototype.trim) {","  String.prototype.trim = function () {","    return this.replace(/^\\s+|\\s+$/g,'');","  };","}"];
_$jscoverage['compat/trim.js'][6]++;
if ((! String.prototype.trim)) {
  _$jscoverage['compat/trim.js'][7]++;
  String.prototype.trim = (function () {
  _$jscoverage['compat/trim.js'][8]++;
  return this.replace(/^\s+|\s+$/g, "");
});
}

/* automatically generated by JSCoverage - do not edit */
try {
  if (typeof top === 'object' && top !== null && typeof top.opener === 'object' && top.opener !== null) {
    // this is a browser window that was opened from another window

    if (! top.opener._$jscoverage) {
      top.opener._$jscoverage = {};
    }
  }
}
catch (e) {}

try {
  if (typeof top === 'object' && top !== null) {
    // this is a browser window

    try {
      if (typeof top.opener === 'object' && top.opener !== null && top.opener._$jscoverage) {
        top._$jscoverage = top.opener._$jscoverage;
      }
    }
    catch (e) {}

    if (! top._$jscoverage) {
      top._$jscoverage = {};
    }
  }
}
catch (e) {}

try {
  if (typeof top === 'object' && top !== null && top._$jscoverage) {
    _$jscoverage = top._$jscoverage;
  }
}
catch (e) {}
if (typeof _$jscoverage !== 'object') {
  _$jscoverage = {};
}
if (! _$jscoverage['array/array.js']) {
  _$jscoverage['array/array.js'] = [];
  _$jscoverage['array/array.js'][1] = 0;
}
_$jscoverage['array/array.js'].source = ["later.array = {};"];
_$jscoverage['array/array.js'][1]++;
later.array = {};
/* automatically generated by JSCoverage - do not edit */
try {
  if (typeof top === 'object' && top !== null && typeof top.opener === 'object' && top.opener !== null) {
    // this is a browser window that was opened from another window

    if (! top.opener._$jscoverage) {
      top.opener._$jscoverage = {};
    }
  }
}
catch (e) {}

try {
  if (typeof top === 'object' && top !== null) {
    // this is a browser window

    try {
      if (typeof top.opener === 'object' && top.opener !== null && top.opener._$jscoverage) {
        top._$jscoverage = top.opener._$jscoverage;
      }
    }
    catch (e) {}

    if (! top._$jscoverage) {
      top._$jscoverage = {};
    }
  }
}
catch (e) {}

try {
  if (typeof top === 'object' && top !== null && top._$jscoverage) {
    _$jscoverage = top._$jscoverage;
  }
}
catch (e) {}
if (typeof _$jscoverage !== 'object') {
  _$jscoverage = {};
}
if (! _$jscoverage['array/sort.js']) {
  _$jscoverage['array/sort.js'] = [];
  _$jscoverage['array/sort.js'][13] = 0;
  _$jscoverage['array/sort.js'][14] = 0;
  _$jscoverage['array/sort.js'][15] = 0;
  _$jscoverage['array/sort.js'][18] = 0;
  _$jscoverage['array/sort.js'][19] = 0;
}
_$jscoverage['array/sort.js'].source = ["/**","* Sort","* (c) 2013 Bill, BunKat LLC.","*","* Sorts an array in natural ascending order, placing zero at the end","* if zeroIsLast is true.","*","* Later is freely distributable under the MIT license.","* For all details and documentation:","*     http://github.com/bunkat/later","*/","","later.array.sort = function (arr, zeroIsLast) {","  arr.sort(function(a,b) {","    return +a - +b;","  });","","  if(zeroIsLast &amp;&amp; arr[0] === 0) {","    arr.push(arr.shift());","  }","};"];
_$jscoverage['array/sort.js'][13]++;
later.array.sort = (function (arr, zeroIsLast) {
  _$jscoverage['array/sort.js'][14]++;
  arr.sort((function (a, b) {
  _$jscoverage['array/sort.js'][15]++;
  return ((+ a) - (+ b));
}));
  _$jscoverage['array/sort.js'][18]++;
  if ((zeroIsLast && (arr[0] === 0))) {
    _$jscoverage['array/sort.js'][19]++;
    arr.push(arr.shift());
  }
});
/* automatically generated by JSCoverage - do not edit */
try {
  if (typeof top === 'object' && top !== null && typeof top.opener === 'object' && top.opener !== null) {
    // this is a browser window that was opened from another window

    if (! top.opener._$jscoverage) {
      top.opener._$jscoverage = {};
    }
  }
}
catch (e) {}

try {
  if (typeof top === 'object' && top !== null) {
    // this is a browser window

    try {
      if (typeof top.opener === 'object' && top.opener !== null && top.opener._$jscoverage) {
        top._$jscoverage = top.opener._$jscoverage;
      }
    }
    catch (e) {}

    if (! top._$jscoverage) {
      top._$jscoverage = {};
    }
  }
}
catch (e) {}

try {
  if (typeof top === 'object' && top !== null && top._$jscoverage) {
    _$jscoverage = top._$jscoverage;
  }
}
catch (e) {}
if (typeof _$jscoverage !== 'object') {
  _$jscoverage = {};
}
if (! _$jscoverage['array/next.js']) {
  _$jscoverage['array/next.js'] = [];
  _$jscoverage['array/next.js'][13] = 0;
  _$jscoverage['array/next.js'][18] = 0;
  _$jscoverage['array/next.js'][22] = 0;
  _$jscoverage['array/next.js'][23] = 0;
  _$jscoverage['array/next.js'][25] = 0;
  _$jscoverage['array/next.js'][26] = 0;
  _$jscoverage['array/next.js'][27] = 0;
  _$jscoverage['array/next.js'][30] = 0;
  _$jscoverage['array/next.js'][31] = 0;
  _$jscoverage['array/next.js'][34] = 0;
  _$jscoverage['array/next.js'][37] = 0;
}
_$jscoverage['array/next.js'].source = ["/**","* Next","* (c) 2013 Bill, BunKat LLC.","*","* Returns the next valid value in a range of values, wrapping as needed. Assumes","* the array has already been sorted.","*","* Later is freely distributable under the MIT license.","* For all details and documentation:","*     http://github.com/bunkat/later","*/","","later.array.next = function (val, values, extent) {","","  // skip UNDEFINED values...","","","  var cur,","      zeroVal = extent[0] === 0 ? 0 : extent[1],","      next = values[0] || zeroVal;","","  for(var i = values.length-1; i &gt; -1; --i) {","    cur = values[i] || zeroVal;","","    if(cur &gt; val) {","      next = cur;","      continue;","    }","","    if(cur === val) {","      return cur;","    }","","    break;","  }","","  return next &lt;= extent[1] ? next : values[0] || zeroVal;","};"];
_$jscoverage['array/next.js'][13]++;
later.array.next = (function (val, values, extent) {
  _$jscoverage['array/next.js'][18]++;
  var cur, zeroVal = ((extent[0] === 0)? 0: extent[1]), next = (values[0] || zeroVal);
  _$jscoverage['array/next.js'][22]++;
  for (var i = (values.length - 1); (i > -1); (--i)) {
    _$jscoverage['array/next.js'][23]++;
    cur = (values[i] || zeroVal);
    _$jscoverage['array/next.js'][25]++;
    if ((cur > val)) {
      _$jscoverage['array/next.js'][26]++;
      next = cur;
      _$jscoverage['array/next.js'][27]++;
      continue;
    }
    _$jscoverage['array/next.js'][30]++;
    if ((cur === val)) {
      _$jscoverage['array/next.js'][31]++;
      return cur;
    }
    _$jscoverage['array/next.js'][34]++;
    break;
}
  _$jscoverage['array/next.js'][37]++;
  return ((next <= extent[1])? next: (values[0] || zeroVal));
});
/* automatically generated by JSCoverage - do not edit */
try {
  if (typeof top === 'object' && top !== null && typeof top.opener === 'object' && top.opener !== null) {
    // this is a browser window that was opened from another window

    if (! top.opener._$jscoverage) {
      top.opener._$jscoverage = {};
    }
  }
}
catch (e) {}

try {
  if (typeof top === 'object' && top !== null) {
    // this is a browser window

    try {
      if (typeof top.opener === 'object' && top.opener !== null && top.opener._$jscoverage) {
        top._$jscoverage = top.opener._$jscoverage;
      }
    }
    catch (e) {}

    if (! top._$jscoverage) {
      top._$jscoverage = {};
    }
  }
}
catch (e) {}

try {
  if (typeof top === 'object' && top !== null && top._$jscoverage) {
    _$jscoverage = top._$jscoverage;
  }
}
catch (e) {}
if (typeof _$jscoverage !== 'object') {
  _$jscoverage = {};
}
if (! _$jscoverage['array/nextinvalid.js']) {
  _$jscoverage['array/nextinvalid.js'] = [];
  _$jscoverage['array/nextinvalid.js'][13] = 0;
  _$jscoverage['array/nextinvalid.js'][15] = 0;
  _$jscoverage['array/nextinvalid.js'][21] = 0;
  _$jscoverage['array/nextinvalid.js'][22] = 0;
  _$jscoverage['array/nextinvalid.js'][23] = 0;
  _$jscoverage['array/nextinvalid.js'][24] = 0;
  _$jscoverage['array/nextinvalid.js'][27] = 0;
  _$jscoverage['array/nextinvalid.js'][28] = 0;
  _$jscoverage['array/nextinvalid.js'][29] = 0;
  _$jscoverage['array/nextinvalid.js'][32] = 0;
  _$jscoverage['array/nextinvalid.js'][33] = 0;
  _$jscoverage['array/nextinvalid.js'][37] = 0;
}
_$jscoverage['array/nextinvalid.js'].source = ["/**","* Next Invalid","* (c) 2013 Bill, BunKat LLC.","*","* Returns the next invalid value in a range of values, wrapping as needed. Assumes","* the array has already been sorted.","*","* Later is freely distributable under the MIT license.","* For all details and documentation:","*     http://github.com/bunkat/later","*/","","later.array.nextInvalid = function (val, values, extent) {","","  var min = extent[0], max = extent[1], len = values.length,","      zeroVal = values[len-1] === 0 &amp;&amp; min !== 0 ? max : 0,","      next = val,","      i = values.indexOf(val),","      start = next;","","  while(next === (values[i] || zeroVal)) {","    next++;","    if(next &gt; max) {","      next = min;","    }","","    i++;","    if(i === len) {","      i = 0;","    }","","    if(next === start) {","      return undefined;","    }","  }","","  return next;","};"];
_$jscoverage['array/nextinvalid.js'][13]++;
later.array.nextInvalid = (function (val, values, extent) {
  _$jscoverage['array/nextinvalid.js'][15]++;
  var min = extent[0], max = extent[1], len = values.length, zeroVal = (((values[(len - 1)] === 0) && (min !== 0))? max: 0), next = val, i = values.indexOf(val), start = next;
  _$jscoverage['array/nextinvalid.js'][21]++;
  while ((next === (values[i] || zeroVal))) {
    _$jscoverage['array/nextinvalid.js'][22]++;
    (next++);
    _$jscoverage['array/nextinvalid.js'][23]++;
    if ((next > max)) {
      _$jscoverage['array/nextinvalid.js'][24]++;
      next = min;
    }
    _$jscoverage['array/nextinvalid.js'][27]++;
    (i++);
    _$jscoverage['array/nextinvalid.js'][28]++;
    if ((i === len)) {
      _$jscoverage['array/nextinvalid.js'][29]++;
      i = 0;
    }
    _$jscoverage['array/nextinvalid.js'][32]++;
    if ((next === start)) {
      _$jscoverage['array/nextinvalid.js'][33]++;
      return undefined;
    }
}
  _$jscoverage['array/nextinvalid.js'][37]++;
  return next;
});
/* automatically generated by JSCoverage - do not edit */
try {
  if (typeof top === 'object' && top !== null && typeof top.opener === 'object' && top.opener !== null) {
    // this is a browser window that was opened from another window

    if (! top.opener._$jscoverage) {
      top.opener._$jscoverage = {};
    }
  }
}
catch (e) {}

try {
  if (typeof top === 'object' && top !== null) {
    // this is a browser window

    try {
      if (typeof top.opener === 'object' && top.opener !== null && top.opener._$jscoverage) {
        top._$jscoverage = top.opener._$jscoverage;
      }
    }
    catch (e) {}

    if (! top._$jscoverage) {
      top._$jscoverage = {};
    }
  }
}
catch (e) {}

try {
  if (typeof top === 'object' && top !== null && top._$jscoverage) {
    _$jscoverage = top._$jscoverage;
  }
}
catch (e) {}
if (typeof _$jscoverage !== 'object') {
  _$jscoverage = {};
}
if (! _$jscoverage['array/prev.js']) {
  _$jscoverage['array/prev.js'] = [];
  _$jscoverage['array/prev.js'][13] = 0;
  _$jscoverage['array/prev.js'][15] = 0;
  _$jscoverage['array/prev.js'][19] = 0;
  _$jscoverage['array/prev.js'][20] = 0;
  _$jscoverage['array/prev.js'][22] = 0;
  _$jscoverage['array/prev.js'][23] = 0;
  _$jscoverage['array/prev.js'][24] = 0;
  _$jscoverage['array/prev.js'][27] = 0;
  _$jscoverage['array/prev.js'][28] = 0;
  _$jscoverage['array/prev.js'][31] = 0;
  _$jscoverage['array/prev.js'][34] = 0;
}
_$jscoverage['array/prev.js'].source = ["/**","* Previous","* (c) 2013 Bill, BunKat LLC.","*","* Returns the previous valid value in a range of values, wrapping as needed. Assumes","* the array has already been sorted.","*","* Later is freely distributable under the MIT license.","* For all details and documentation:","*     http://github.com/bunkat/later","*/","","later.array.prev = function (val, values, extent) {","","  var cur, len = values.length,","      zeroVal = extent[0] === 0 ? 0 : extent[1],","      prev = values[len-1] || zeroVal;","","  for(var i = 0; i &lt; len; i++) {","    cur = values[i] || zeroVal;","","    if(cur &lt; val) {","      prev = cur;","      continue;","    }","","    if(cur === val) {","      return cur;","    }","","    break;","  }","","  return prev;","};"];
_$jscoverage['array/prev.js'][13]++;
later.array.prev = (function (val, values, extent) {
  _$jscoverage['array/prev.js'][15]++;
  var cur, len = values.length, zeroVal = ((extent[0] === 0)? 0: extent[1]), prev = (values[(len - 1)] || zeroVal);
  _$jscoverage['array/prev.js'][19]++;
  for (var i = 0; (i < len); (i++)) {
    _$jscoverage['array/prev.js'][20]++;
    cur = (values[i] || zeroVal);
    _$jscoverage['array/prev.js'][22]++;
    if ((cur < val)) {
      _$jscoverage['array/prev.js'][23]++;
      prev = cur;
      _$jscoverage['array/prev.js'][24]++;
      continue;
    }
    _$jscoverage['array/prev.js'][27]++;
    if ((cur === val)) {
      _$jscoverage['array/prev.js'][28]++;
      return cur;
    }
    _$jscoverage['array/prev.js'][31]++;
    break;
}
  _$jscoverage['array/prev.js'][34]++;
  return prev;
});
/* automatically generated by JSCoverage - do not edit */
try {
  if (typeof top === 'object' && top !== null && typeof top.opener === 'object' && top.opener !== null) {
    // this is a browser window that was opened from another window

    if (! top.opener._$jscoverage) {
      top.opener._$jscoverage = {};
    }
  }
}
catch (e) {}

try {
  if (typeof top === 'object' && top !== null) {
    // this is a browser window

    try {
      if (typeof top.opener === 'object' && top.opener !== null && top.opener._$jscoverage) {
        top._$jscoverage = top.opener._$jscoverage;
      }
    }
    catch (e) {}

    if (! top._$jscoverage) {
      top._$jscoverage = {};
    }
  }
}
catch (e) {}

try {
  if (typeof top === 'object' && top !== null && top._$jscoverage) {
    _$jscoverage = top._$jscoverage;
  }
}
catch (e) {}
if (typeof _$jscoverage !== 'object') {
  _$jscoverage = {};
}
if (! _$jscoverage['array/previnvalid.js']) {
  _$jscoverage['array/previnvalid.js'] = [];
  _$jscoverage['array/previnvalid.js'][13] = 0;
  _$jscoverage['array/previnvalid.js'][15] = 0;
  _$jscoverage['array/previnvalid.js'][20] = 0;
  _$jscoverage['array/previnvalid.js'][21] = 0;
  _$jscoverage['array/previnvalid.js'][22] = 0;
  _$jscoverage['array/previnvalid.js'][23] = 0;
  _$jscoverage['array/previnvalid.js'][26] = 0;
  _$jscoverage['array/previnvalid.js'][27] = 0;
  _$jscoverage['array/previnvalid.js'][28] = 0;
  _$jscoverage['array/previnvalid.js'][32] = 0;
}
_$jscoverage['array/previnvalid.js'].source = ["/**","* Previous Invalid","* (c) 2013 Bill, BunKat LLC.","*","* Returns the previous invalid value in a range of values, wrapping as needed. Assumes","* the array has already been sorted.","*","* Later is freely distributable under the MIT license.","* For all details and documentation:","*     http://github.com/bunkat/later","*/","","later.array.prevInvalid = function (val, values, extent) {","","  var min = extent[0], max = extent[1], len = values.length,","      zeroVal = values[len-1] === 0 &amp;&amp; min !== 0 ? max : 0,","      next = val,","      i = values.indexOf(val);","","  while(next === (values[i] || zeroVal)) {","    next--;","    if(next &lt; min) {","      next = max;","    }","","    i--;","    if(i === -1) {","      i = len-1;","    }","  }","","  return next;","};"];
_$jscoverage['array/previnvalid.js'][13]++;
later.array.prevInvalid = (function (val, values, extent) {
  _$jscoverage['array/previnvalid.js'][15]++;
  var min = extent[0], max = extent[1], len = values.length, zeroVal = (((values[(len - 1)] === 0) && (min !== 0))? max: 0), next = val, i = values.indexOf(val);
  _$jscoverage['array/previnvalid.js'][20]++;
  while ((next === (values[i] || zeroVal))) {
    _$jscoverage['array/previnvalid.js'][21]++;
    (next--);
    _$jscoverage['array/previnvalid.js'][22]++;
    if ((next < min)) {
      _$jscoverage['array/previnvalid.js'][23]++;
      next = max;
    }
    _$jscoverage['array/previnvalid.js'][26]++;
    (i--);
    _$jscoverage['array/previnvalid.js'][27]++;
    if ((i === -1)) {
      _$jscoverage['array/previnvalid.js'][28]++;
      i = (len - 1);
    }
}
  _$jscoverage['array/previnvalid.js'][32]++;
  return next;
});
/* automatically generated by JSCoverage - do not edit */
try {
  if (typeof top === 'object' && top !== null && typeof top.opener === 'object' && top.opener !== null) {
    // this is a browser window that was opened from another window

    if (! top.opener._$jscoverage) {
      top.opener._$jscoverage = {};
    }
  }
}
catch (e) {}

try {
  if (typeof top === 'object' && top !== null) {
    // this is a browser window

    try {
      if (typeof top.opener === 'object' && top.opener !== null && top.opener._$jscoverage) {
        top._$jscoverage = top.opener._$jscoverage;
      }
    }
    catch (e) {}

    if (! top._$jscoverage) {
      top._$jscoverage = {};
    }
  }
}
catch (e) {}

try {
  if (typeof top === 'object' && top !== null && top._$jscoverage) {
    _$jscoverage = top._$jscoverage;
  }
}
catch (e) {}
if (typeof _$jscoverage !== 'object') {
  _$jscoverage = {};
}
if (! _$jscoverage['array/minindex.js']) {
  _$jscoverage['array/minindex.js'] = [];
  _$jscoverage['array/minindex.js'][3] = 0;
  _$jscoverage['array/minindex.js'][4] = 0;
  _$jscoverage['array/minindex.js'][7] = 0;
  _$jscoverage['array/minindex.js'][8] = 0;
  _$jscoverage['array/minindex.js'][9] = 0;
  _$jscoverage['array/minindex.js'][10] = 0;
  _$jscoverage['array/minindex.js'][14] = 0;
}
_$jscoverage['array/minindex.js'].source = ["","","later.array.minIndex = function(arr) {","  var min = arr[0],","      minIdx = 0;","","  for(var i = 1; i &lt; arr.length; i++) {","    if(arr[i] &lt; min) {","      min = arr[i];","      minIdx = i;","    }","  }","","  return minIdx;","};"];
_$jscoverage['array/minindex.js'][3]++;
later.array.minIndex = (function (arr) {
  _$jscoverage['array/minindex.js'][4]++;
  var min = arr[0], minIdx = 0;
  _$jscoverage['array/minindex.js'][7]++;
  for (var i = 1; (i < arr.length); (i++)) {
    _$jscoverage['array/minindex.js'][8]++;
    if ((arr[i] < min)) {
      _$jscoverage['array/minindex.js'][9]++;
      min = arr[i];
      _$jscoverage['array/minindex.js'][10]++;
      minIdx = i;
    }
}
  _$jscoverage['array/minindex.js'][14]++;
  return minIdx;
});
/* automatically generated by JSCoverage - do not edit */
try {
  if (typeof top === 'object' && top !== null && typeof top.opener === 'object' && top.opener !== null) {
    // this is a browser window that was opened from another window

    if (! top.opener._$jscoverage) {
      top.opener._$jscoverage = {};
    }
  }
}
catch (e) {}

try {
  if (typeof top === 'object' && top !== null) {
    // this is a browser window

    try {
      if (typeof top.opener === 'object' && top.opener !== null && top.opener._$jscoverage) {
        top._$jscoverage = top.opener._$jscoverage;
      }
    }
    catch (e) {}

    if (! top._$jscoverage) {
      top._$jscoverage = {};
    }
  }
}
catch (e) {}

try {
  if (typeof top === 'object' && top !== null && top._$jscoverage) {
    _$jscoverage = top._$jscoverage;
  }
}
catch (e) {}
if (typeof _$jscoverage !== 'object') {
  _$jscoverage = {};
}
if (! _$jscoverage['array/maxindex.js']) {
  _$jscoverage['array/maxindex.js'] = [];
  _$jscoverage['array/maxindex.js'][3] = 0;
  _$jscoverage['array/maxindex.js'][4] = 0;
  _$jscoverage['array/maxindex.js'][7] = 0;
  _$jscoverage['array/maxindex.js'][8] = 0;
  _$jscoverage['array/maxindex.js'][9] = 0;
  _$jscoverage['array/maxindex.js'][10] = 0;
  _$jscoverage['array/maxindex.js'][14] = 0;
}
_$jscoverage['array/maxindex.js'].source = ["","","later.array.maxIndex = function(arr) {","  var max = arr[0],","      maxIdx = 0;","","  for(var i = 1; i &lt; arr.length; i++) {","    if(arr[i] &gt; max) {","      max = arr[i];","      maxIdx = i;","    }","  }","","  return maxIdx;","};"];
_$jscoverage['array/maxindex.js'][3]++;
later.array.maxIndex = (function (arr) {
  _$jscoverage['array/maxindex.js'][4]++;
  var max = arr[0], maxIdx = 0;
  _$jscoverage['array/maxindex.js'][7]++;
  for (var i = 1; (i < arr.length); (i++)) {
    _$jscoverage['array/maxindex.js'][8]++;
    if ((arr[i] > max)) {
      _$jscoverage['array/maxindex.js'][9]++;
      max = arr[i];
      _$jscoverage['array/maxindex.js'][10]++;
      maxIdx = i;
    }
}
  _$jscoverage['array/maxindex.js'][14]++;
  return maxIdx;
});
/* automatically generated by JSCoverage - do not edit */
try {
  if (typeof top === 'object' && top !== null && typeof top.opener === 'object' && top.opener !== null) {
    // this is a browser window that was opened from another window

    if (! top.opener._$jscoverage) {
      top.opener._$jscoverage = {};
    }
  }
}
catch (e) {}

try {
  if (typeof top === 'object' && top !== null) {
    // this is a browser window

    try {
      if (typeof top.opener === 'object' && top.opener !== null && top.opener._$jscoverage) {
        top._$jscoverage = top.opener._$jscoverage;
      }
    }
    catch (e) {}

    if (! top._$jscoverage) {
      top._$jscoverage = {};
    }
  }
}
catch (e) {}

try {
  if (typeof top === 'object' && top !== null && top._$jscoverage) {
    _$jscoverage = top._$jscoverage;
  }
}
catch (e) {}
if (typeof _$jscoverage !== 'object') {
  _$jscoverage = {};
}
if (! _$jscoverage['constraint/day.js']) {
  _$jscoverage['constraint/day.js'] = [];
  _$jscoverage['constraint/day.js'][11] = 0;
  _$jscoverage['constraint/day.js'][30] = 0;
  _$jscoverage['constraint/day.js'][40] = 0;
  _$jscoverage['constraint/day.js'][42] = 0;
  _$jscoverage['constraint/day.js'][45] = 0;
  _$jscoverage['constraint/day.js'][46] = 0;
  _$jscoverage['constraint/day.js'][49] = 0;
  _$jscoverage['constraint/day.js'][58] = 0;
  _$jscoverage['constraint/day.js'][68] = 0;
  _$jscoverage['constraint/day.js'][81] = 0;
  _$jscoverage['constraint/day.js'][84] = 0;
  _$jscoverage['constraint/day.js'][86] = 0;
  _$jscoverage['constraint/day.js'][102] = 0;
  _$jscoverage['constraint/day.js'][105] = 0;
  _$jscoverage['constraint/day.js'][107] = 0;
}
_$jscoverage['constraint/day.js'].source = ["/**","* Day Constraint (D)","* (c) 2013 Bill, BunKat LLC.","*","* Definition for a day of month (date) constraint type.","*","* Later is freely distributable under the MIT license.","* For all details and documentation:","*     http://github.com/bunkat/later","*/","later.day = later.D = {","","  /**","  * The name of this constraint.","  */","  name: 'day',","","  /**","  * The rough amount of seconds between start and end for this constraint.","  * (doesn't need to be exact)","  */","  range: 86400,","","  /**","  * The day value of the specified date.","  *","  * @param {Date} d: The date to calculate the value of","  */","  val: function(d) {","    return d.D || (d.D = later.date.getDate.call(d));","  },","","  /**","  * The minimum and maximum valid day values of the month specified.","  * Zero to specify the last day of the month.","  *","  * @param {Date} d: The date indicating the month to find the extent of","  */","  extent: function(d) {","    if(d.DExtent) return d.DExtent;","","    var month = later.M.val(d),","        max = later.date.daysInMonth[month];","","    if(month === 2 &amp;&amp; later.dy.extent(d)[1] === 366) {","      max = max+1;","    }","","    return (d.DExtent = [1, max]);","  },","","  /**","  * The start of the day of the specified date.","  *","  * @param {Date} d: The specified date","  */","  start: function(d) {","    return d.DStart || (d.DStart = later.date.next(","      later.Y.val(d), later.M.val(d), later.D.val(d)));","  },","","  /**","  * The end of the day of the specified date.","  *","  * @param {Date} d: The specified date","  */","  end: function(d) {","    return d.DEnd || (d.DEnd = later.date.prev(","      later.Y.val(d), later.M.val(d), later.D.val(d)));","  },","","  /**","  * Returns the start of the next instance of the day value indicated. Returns","  * the first day of the next month if val is greater than the number of","  * days in the following month.","  *","  * @param {Date} d: The starting date","  * @param {int} val: The desired value, must be within extent","  */","  next: function(d, val) {","    var month = later.date.nextRollover(d, val, later.D, later.M),","        DMax = later.D.extent(month)[1];","","    val = val &gt; DMax ? 1 : val;","","    return later.date.next(","      later.Y.val(month),","      later.M.val(month),","      val","    );","  },","","  /**","  * Returns the end of the previous instance of the day value indicated. Returns","  * the last day in the previous month if val is greater than the number of days","  * in the previous month.","  *","  * @param {Date} d: The starting date","  * @param {int} val: The desired value, must be within extent","  */","  prev: function(d, val) {","    var month = later.date.prevRollover(d, val, later.D, later.M),","        DMax = later.D.extent(month)[1];","","    val = val &gt; DMax ? DMax : val;","","    return later.date.prev(","      later.Y.val(month),","      later.M.val(month),","      val","    );","  }","","};"];
_$jscoverage['constraint/day.js'][11]++;
later.day = (later.D = {name: "day", range: 86400, val: (function (d) {
  _$jscoverage['constraint/day.js'][30]++;
  return (d.D || (d.D = later.date.getDate.call(d)));
}), extent: (function (d) {
  _$jscoverage['constraint/day.js'][40]++;
  if (d.DExtent) {
    _$jscoverage['constraint/day.js'][40]++;
    return d.DExtent;
  }
  _$jscoverage['constraint/day.js'][42]++;
  var month = later.M.val(d), max = later.date.daysInMonth[month];
  _$jscoverage['constraint/day.js'][45]++;
  if (((month === 2) && (later.dy.extent(d)[1] === 366))) {
    _$jscoverage['constraint/day.js'][46]++;
    max = (max + 1);
  }
  _$jscoverage['constraint/day.js'][49]++;
  return (d.DExtent = [1, max]);
}), start: (function (d) {
  _$jscoverage['constraint/day.js'][58]++;
  return (d.DStart || (d.DStart = later.date.next(later.Y.val(d), later.M.val(d), later.D.val(d))));
}), end: (function (d) {
  _$jscoverage['constraint/day.js'][68]++;
  return (d.DEnd || (d.DEnd = later.date.prev(later.Y.val(d), later.M.val(d), later.D.val(d))));
}), next: (function (d, val) {
  _$jscoverage['constraint/day.js'][81]++;
  var month = later.date.nextRollover(d, val, later.D, later.M), DMax = later.D.extent(month)[1];
  _$jscoverage['constraint/day.js'][84]++;
  val = ((val > DMax)? 1: val);
  _$jscoverage['constraint/day.js'][86]++;
  return later.date.next(later.Y.val(month), later.M.val(month), val);
}), prev: (function (d, val) {
  _$jscoverage['constraint/day.js'][102]++;
  var month = later.date.prevRollover(d, val, later.D, later.M), DMax = later.D.extent(month)[1];
  _$jscoverage['constraint/day.js'][105]++;
  val = ((val > DMax)? DMax: val);
  _$jscoverage['constraint/day.js'][107]++;
  return later.date.prev(later.Y.val(month), later.M.val(month), val);
})});
/* automatically generated by JSCoverage - do not edit */
try {
  if (typeof top === 'object' && top !== null && typeof top.opener === 'object' && top.opener !== null) {
    // this is a browser window that was opened from another window

    if (! top.opener._$jscoverage) {
      top.opener._$jscoverage = {};
    }
  }
}
catch (e) {}

try {
  if (typeof top === 'object' && top !== null) {
    // this is a browser window

    try {
      if (typeof top.opener === 'object' && top.opener !== null && top.opener._$jscoverage) {
        top._$jscoverage = top.opener._$jscoverage;
      }
    }
    catch (e) {}

    if (! top._$jscoverage) {
      top._$jscoverage = {};
    }
  }
}
catch (e) {}

try {
  if (typeof top === 'object' && top !== null && top._$jscoverage) {
    _$jscoverage = top._$jscoverage;
  }
}
catch (e) {}
if (typeof _$jscoverage !== 'object') {
  _$jscoverage = {};
}
if (! _$jscoverage['constraint/dayofweekcount.js']) {
  _$jscoverage['constraint/dayofweekcount.js'] = [];
  _$jscoverage['constraint/dayofweekcount.js'][12] = 0;
  _$jscoverage['constraint/dayofweekcount.js'][31] = 0;
  _$jscoverage['constraint/dayofweekcount.js'][41] = 0;
  _$jscoverage['constraint/dayofweekcount.js'][51] = 0;
  _$jscoverage['constraint/dayofweekcount.js'][65] = 0;
  _$jscoverage['constraint/dayofweekcount.js'][79] = 0;
  _$jscoverage['constraint/dayofweekcount.js'][82] = 0;
  _$jscoverage['constraint/dayofweekcount.js'][84] = 0;
  _$jscoverage['constraint/dayofweekcount.js'][98] = 0;
  _$jscoverage['constraint/dayofweekcount.js'][101] = 0;
  _$jscoverage['constraint/dayofweekcount.js'][103] = 0;
}
_$jscoverage['constraint/dayofweekcount.js'].source = ["/**","* Day of Week Count Constraint (dc)","* (c) 2013 Bill, BunKat LLC.","*","* Definition for a day of week count constraint type. This constraint is used","* to specify schedules like '2nd Tuesday of every month'.","*","* Later is freely distributable under the MIT license.","* For all details and documentation:","*     http://github.com/bunkat/later","*/","later.dayOfWeekCount = later.dc = {","","  /**","  * The name of this constraint.","  */","  name: 'day of week count',","","  /**","  * The rough amount of seconds between start and end for this constraint.","  * (doesn't need to be exact)","  */","  range: 604800,","","  /**","  * The day of week count value of the specified date.","  *","  * @param {Date} d: The date to calculate the value of","  */","  val: function(d) {","    return d.dc || (d.dc = Math.floor((later.D.val(d)-1)/7)+1);","  },","","  /**","  * The minimum and maximum valid day values of the month specified.","  * Zero to specify the last day of week count of the month.","  *","  * @param {Date} d: The date indicating the month to find the extent of","  */","  extent: function(d) {","    return d.dcExtent || (d.dcExtent = [1, Math.ceil(later.D.extent(d)[1] /7)]);","  },","","  /**","  * The first day of the month with the same day of week count as the date","  * specified.","  *","  * @param {Date} d: The specified date","  */","  start: function(d) {","    return d.dcStart || (d.dcStart =","      later.date.next(","        later.Y.val(d),","        later.M.val(d),","        Math.max(1, ((later.dc.val(d) - 1) * 7) + 1 || 1)));","  },","","  /**","  * The last day of the month with the same day of week count as the date","  * specified.","  *","  * @param {Date} d: The specified date","  */","  end: function(d) {","    return d.dcEnd || (d.dcEnd =","      later.date.prev(","        later.Y.val(d),","        later.M.val(d),","        Math.min(later.dc.val(d) * 7, later.D.extent(d)[1])));","  },","","  /**","  * Returns the next earliest date with the day of week count specified.","  *","  * @param {Date} d: The starting date","  * @param {int} val: The desired value, must be within extent","  */","  next: function(d, val) {","    var month = later.date.nextRollover(d, val, later.dc, later.M),","        dcMax = later.dc.extent(month)[1];","","    val = val &gt; dcMax ? 1 : val;","","    return later.date.next(","      later.Y.val(month),","      later.M.val(month),","      1 + (7 * (val - 1))","    );","  },","","  /**","  * Returns the closest previous date with the day of week count specified.","  *","  * @param {Date} d: The starting date","  * @param {int} val: The desired value, must be within extent","  */","  prev: function(d, val) {","    var month = later.date.prevRollover(d, val, later.dc, later.M),","        dcMax = later.dc.extent(month)[1];","","    val = val &gt; dcMax ? dcMax : val;","","    return later.dc.end(later.date.prev(","      later.Y.val(month),","      later.M.val(month),","      1 + (7 * (val - 1))","    ));","  }","","};"];
_$jscoverage['constraint/dayofweekcount.js'][12]++;
later.dayOfWeekCount = (later.dc = {name: "day of week count", range: 604800, val: (function (d) {
  _$jscoverage['constraint/dayofweekcount.js'][31]++;
  return (d.dc || (d.dc = (Math.floor(((later.D.val(d) - 1) / 7)) + 1)));
}), extent: (function (d) {
  _$jscoverage['constraint/dayofweekcount.js'][41]++;
  return (d.dcExtent || (d.dcExtent = [1, Math.ceil((later.D.extent(d)[1] / 7))]));
}), start: (function (d) {
  _$jscoverage['constraint/dayofweekcount.js'][51]++;
  return (d.dcStart || (d.dcStart = later.date.next(later.Y.val(d), later.M.val(d), Math.max(1, ((((later.dc.val(d) - 1) * 7) + 1) || 1)))));
}), end: (function (d) {
  _$jscoverage['constraint/dayofweekcount.js'][65]++;
  return (d.dcEnd || (d.dcEnd = later.date.prev(later.Y.val(d), later.M.val(d), Math.min((later.dc.val(d) * 7), later.D.extent(d)[1]))));
}), next: (function (d, val) {
  _$jscoverage['constraint/dayofweekcount.js'][79]++;
  var month = later.date.nextRollover(d, val, later.dc, later.M), dcMax = later.dc.extent(month)[1];
  _$jscoverage['constraint/dayofweekcount.js'][82]++;
  val = ((val > dcMax)? 1: val);
  _$jscoverage['constraint/dayofweekcount.js'][84]++;
  return later.date.next(later.Y.val(month), later.M.val(month), (1 + (7 * (val - 1))));
}), prev: (function (d, val) {
  _$jscoverage['constraint/dayofweekcount.js'][98]++;
  var month = later.date.prevRollover(d, val, later.dc, later.M), dcMax = later.dc.extent(month)[1];
  _$jscoverage['constraint/dayofweekcount.js'][101]++;
  val = ((val > dcMax)? dcMax: val);
  _$jscoverage['constraint/dayofweekcount.js'][103]++;
  return later.dc.end(later.date.prev(later.Y.val(month), later.M.val(month), (1 + (7 * (val - 1)))));
})});
/* automatically generated by JSCoverage - do not edit */
try {
  if (typeof top === 'object' && top !== null && typeof top.opener === 'object' && top.opener !== null) {
    // this is a browser window that was opened from another window

    if (! top.opener._$jscoverage) {
      top.opener._$jscoverage = {};
    }
  }
}
catch (e) {}

try {
  if (typeof top === 'object' && top !== null) {
    // this is a browser window

    try {
      if (typeof top.opener === 'object' && top.opener !== null && top.opener._$jscoverage) {
        top._$jscoverage = top.opener._$jscoverage;
      }
    }
    catch (e) {}

    if (! top._$jscoverage) {
      top._$jscoverage = {};
    }
  }
}
catch (e) {}

try {
  if (typeof top === 'object' && top !== null && top._$jscoverage) {
    _$jscoverage = top._$jscoverage;
  }
}
catch (e) {}
if (typeof _$jscoverage !== 'object') {
  _$jscoverage = {};
}
if (! _$jscoverage['constraint/dayofweek.js']) {
  _$jscoverage['constraint/dayofweek.js'] = [];
  _$jscoverage['constraint/dayofweek.js'][11] = 0;
  _$jscoverage['constraint/dayofweek.js'][30] = 0;
  _$jscoverage['constraint/dayofweek.js'][38] = 0;
  _$jscoverage['constraint/dayofweek.js'][47] = 0;
  _$jscoverage['constraint/dayofweek.js'][56] = 0;
  _$jscoverage['constraint/dayofweek.js'][66] = 0;
  _$jscoverage['constraint/dayofweek.js'][79] = 0;
}
_$jscoverage['constraint/dayofweek.js'].source = ["/**","* Day of Week Constraint (dw)","* (c) 2013 Bill, BunKat LLC.","*","* Definition for a day of week constraint type.","*","* Later is freely distributable under the MIT license.","* For all details and documentation:","*     http://github.com/bunkat/later","*/","later.dayOfWeek = later.dw = later.d = {","","  /**","  * The name of this constraint.","  */","  name: 'day of week',","","  /**","  * The rough amount of seconds between start and end for this constraint.","  * (doesn't need to be exact)","  */","  range: 86400,","","  /**","  * The day of week value of the specified date.","  *","  * @param {Date} d: The date to calculate the value of","  */","  val: function(d) {","    return d.dw || (d.dw = later.date.getDay.call(d)+1);","  },","","  /**","  * The minimum and maximum valid day of week values. Unlike the standard","  * Date object, Later day of week goes from 1 to 7.","  */","  extent: function() {","    return [1, 7];","  },","","  /**","  * The start of the day of the specified date.","  *","  * @param {Date} d: The specified date","  */","  start: function(d) {","    return later.D.start(d);","  },","","  /**","  * The end of the day of the specified date.","  *","  * @param {Date} d: The specified date","  */","  end: function(d) {","    return later.D.end(d);","  },","","  /**","  * Returns the start of the next instance of the day of week value indicated.","  *","  * @param {Date} d: The starting date","  * @param {int} val: The desired value, must be within extent","  */","  next: function(d, val) {","    return later.date.next(","      later.Y.val(d),","      later.M.val(d),","      later.D.val(d) + (val - later.dw.val(d)) + (val &lt;= later.dw.val(d) ? 7 : 0));","  },","","  /**","  * Returns the end of the previous instance of the day of week value indicated.","  *","  * @param {Date} d: The starting date","  * @param {int} val: The desired value, must be within extent","  */","  prev: function(d, val) {","    return later.date.prev(","      later.Y.val(d),","      later.M.val(d),","      later.D.val(d) + (val - later.dw.val(d)) + (val &gt;= later.dw.val(d) ? -7 : 0));","  }","};"];
_$jscoverage['constraint/dayofweek.js'][11]++;
later.dayOfWeek = (later.dw = (later.d = {name: "day of week", range: 86400, val: (function (d) {
  _$jscoverage['constraint/dayofweek.js'][30]++;
  return (d.dw || (d.dw = (later.date.getDay.call(d) + 1)));
}), extent: (function () {
  _$jscoverage['constraint/dayofweek.js'][38]++;
  return [1, 7];
}), start: (function (d) {
  _$jscoverage['constraint/dayofweek.js'][47]++;
  return later.D.start(d);
}), end: (function (d) {
  _$jscoverage['constraint/dayofweek.js'][56]++;
  return later.D.end(d);
}), next: (function (d, val) {
  _$jscoverage['constraint/dayofweek.js'][66]++;
  return later.date.next(later.Y.val(d), later.M.val(d), (later.D.val(d) + (val - later.dw.val(d)) + ((val <= later.dw.val(d))? 7: 0)));
}), prev: (function (d, val) {
  _$jscoverage['constraint/dayofweek.js'][79]++;
  return later.date.prev(later.Y.val(d), later.M.val(d), (later.D.val(d) + (val - later.dw.val(d)) + ((val >= later.dw.val(d))? -7: 0)));
})}));
/* automatically generated by JSCoverage - do not edit */
try {
  if (typeof top === 'object' && top !== null && typeof top.opener === 'object' && top.opener !== null) {
    // this is a browser window that was opened from another window

    if (! top.opener._$jscoverage) {
      top.opener._$jscoverage = {};
    }
  }
}
catch (e) {}

try {
  if (typeof top === 'object' && top !== null) {
    // this is a browser window

    try {
      if (typeof top.opener === 'object' && top.opener !== null && top.opener._$jscoverage) {
        top._$jscoverage = top.opener._$jscoverage;
      }
    }
    catch (e) {}

    if (! top._$jscoverage) {
      top._$jscoverage = {};
    }
  }
}
catch (e) {}

try {
  if (typeof top === 'object' && top !== null && top._$jscoverage) {
    _$jscoverage = top._$jscoverage;
  }
}
catch (e) {}
if (typeof _$jscoverage !== 'object') {
  _$jscoverage = {};
}
if (! _$jscoverage['constraint/dayofyear.js']) {
  _$jscoverage['constraint/dayofyear.js'] = [];
  _$jscoverage['constraint/dayofyear.js'][11] = 0;
  _$jscoverage['constraint/dayofyear.js'][30] = 0;
  _$jscoverage['constraint/dayofyear.js'][41] = 0;
  _$jscoverage['constraint/dayofyear.js'][45] = 0;
  _$jscoverage['constraint/dayofyear.js'][54] = 0;
  _$jscoverage['constraint/dayofyear.js'][63] = 0;
  _$jscoverage['constraint/dayofyear.js'][73] = 0;
  _$jscoverage['constraint/dayofyear.js'][76] = 0;
  _$jscoverage['constraint/dayofyear.js'][78] = 0;
  _$jscoverage['constraint/dayofyear.js'][93] = 0;
  _$jscoverage['constraint/dayofyear.js'][96] = 0;
  _$jscoverage['constraint/dayofyear.js'][98] = 0;
}
_$jscoverage['constraint/dayofyear.js'].source = ["/**","* Day of Year Constraint (dy)","* (c) 2013 Bill, BunKat LLC.","*","* Definition for a day of year constraint type.","*","* Later is freely distributable under the MIT license.","* For all details and documentation:","*     http://github.com/bunkat/later","*/","later.dayOfYear = later.dy = {","","  /**","  * The name of this constraint.","  */","  name: 'day of year',","","  /**","  * The rough amount of seconds between start and end for this constraint.","  * (doesn't need to be exact)","  */","  range: 86400,","","  /**","  * The day of year value of the specified date.","  *","  * @param {Date} d: The date to calculate the value of","  */","  val: function(d) {","    return d.dy || (d.dy =","      Math.ceil(1 + (later.D.start(d).getTime() - later.Y.start(d).getTime()) / later.DAY));","  },","","  /**","  * The minimum and maximum valid day of year values of the month specified.","  * Zero indicates the last day of the year.","  *","  * @param {Date} d: The date indicating the month to find the extent of","  */","  extent: function(d) {","    var year = later.Y.val(d);","","    // shortcut on finding leap years since this function gets called a lot","    // works between 1901 and 2099","    return d.dyExtent || (d.dyExtent = [1, year % 4 ? 365 : 366]);","  },","","  /**","  * The start of the day of year of the specified date.","  *","  * @param {Date} d: The specified date","  */","  start: function(d) {","    return later.D.start(d);","  },","","  /**","  * The end of the day of year of the specified date.","  *","  * @param {Date} d: The specified date","  */","  end: function(d) {","    return later.D.end(d);","  },","","  /**","  * Returns the start of the next instance of the day of year value indicated.","  *","  * @param {Date} d: The starting date","  * @param {int} val: The desired value, must be within extent","  */","  next: function(d, val) {","    var year = later.date.nextRollover(d, val, later.dy, later.Y),","        dyMax = later.dy.extent(year)[1];","","    val = val &gt; dyMax ? 1 : val;","","    return later.date.next(","      later.Y.val(year),","      later.M.val(year),","      val","    );","","  },","","  /**","  * Returns the end of the previous instance of the day of year value indicated.","  *","  * @param {Date} d: The starting date","  * @param {int} val: The desired value, must be within extent","  */","  prev: function(d, val) {","    var year = later.date.prevRollover(d, val, later.dy, later.Y),","        dyMax = later.dy.extent(year)[1];","","    val = val &gt; dyMax ? dyMax : val;","","    return later.date.prev(","      later.Y.val(year),","      later.M.val(year),","      val","    );","  }","","};"];
_$jscoverage['constraint/dayofyear.js'][11]++;
later.dayOfYear = (later.dy = {name: "day of year", range: 86400, val: (function (d) {
  _$jscoverage['constraint/dayofyear.js'][30]++;
  return (d.dy || (d.dy = Math.ceil((1 + ((later.D.start(d).getTime() - later.Y.start(d).getTime()) / later.DAY)))));
}), extent: (function (d) {
  _$jscoverage['constraint/dayofyear.js'][41]++;
  var year = later.Y.val(d);
  _$jscoverage['constraint/dayofyear.js'][45]++;
  return (d.dyExtent || (d.dyExtent = [1, ((year % 4)? 365: 366)]));
}), start: (function (d) {
  _$jscoverage['constraint/dayofyear.js'][54]++;
  return later.D.start(d);
}), end: (function (d) {
  _$jscoverage['constraint/dayofyear.js'][63]++;
  return later.D.end(d);
}), next: (function (d, val) {
  _$jscoverage['constraint/dayofyear.js'][73]++;
  var year = later.date.nextRollover(d, val, later.dy, later.Y), dyMax = later.dy.extent(year)[1];
  _$jscoverage['constraint/dayofyear.js'][76]++;
  val = ((val > dyMax)? 1: val);
  _$jscoverage['constraint/dayofyear.js'][78]++;
  return later.date.next(later.Y.val(year), later.M.val(year), val);
}), prev: (function (d, val) {
  _$jscoverage['constraint/dayofyear.js'][93]++;
  var year = later.date.prevRollover(d, val, later.dy, later.Y), dyMax = later.dy.extent(year)[1];
  _$jscoverage['constraint/dayofyear.js'][96]++;
  val = ((val > dyMax)? dyMax: val);
  _$jscoverage['constraint/dayofyear.js'][98]++;
  return later.date.prev(later.Y.val(year), later.M.val(year), val);
})});
/* automatically generated by JSCoverage - do not edit */
try {
  if (typeof top === 'object' && top !== null && typeof top.opener === 'object' && top.opener !== null) {
    // this is a browser window that was opened from another window

    if (! top.opener._$jscoverage) {
      top.opener._$jscoverage = {};
    }
  }
}
catch (e) {}

try {
  if (typeof top === 'object' && top !== null) {
    // this is a browser window

    try {
      if (typeof top.opener === 'object' && top.opener !== null && top.opener._$jscoverage) {
        top._$jscoverage = top.opener._$jscoverage;
      }
    }
    catch (e) {}

    if (! top._$jscoverage) {
      top._$jscoverage = {};
    }
  }
}
catch (e) {}

try {
  if (typeof top === 'object' && top !== null && top._$jscoverage) {
    _$jscoverage = top._$jscoverage;
  }
}
catch (e) {}
if (typeof _$jscoverage !== 'object') {
  _$jscoverage = {};
}
if (! _$jscoverage['constraint/hour.js']) {
  _$jscoverage['constraint/hour.js'] = [];
  _$jscoverage['constraint/hour.js'][11] = 0;
  _$jscoverage['constraint/hour.js'][30] = 0;
  _$jscoverage['constraint/hour.js'][37] = 0;
  _$jscoverage['constraint/hour.js'][46] = 0;
  _$jscoverage['constraint/hour.js'][56] = 0;
  _$jscoverage['constraint/hour.js'][67] = 0;
  _$jscoverage['constraint/hour.js'][74] = 0;
  _$jscoverage['constraint/hour.js'][75] = 0;
  _$jscoverage['constraint/hour.js'][82] = 0;
  _$jscoverage['constraint/hour.js'][93] = 0;
}
_$jscoverage['constraint/hour.js'].source = ["/**","* Hour Constraint (H)","* (c) 2013 Bill, BunKat LLC.","*","* Definition for a hour constraint type.","*","* Later is freely distributable under the MIT license.","* For all details and documentation:","*     http://github.com/bunkat/later","*/","later.hour = later.h = {","","  /**","  * The name of this constraint.","  */","  name: 'hour',","","  /**","  * The rough amount of seconds between start and end for this constraint.","  * (doesn't need to be exact)","  */","  range: 3600,","","  /**","  * The hour value of the specified date.","  *","  * @param {Date} d: The date to calculate the value of","  */","  val: function(d) {","    return d.h || (d.h = later.date.getHour.call(d));","  },","","  /**","  * The minimum and maximum valid hour values.","  */","  extent: function() {","    return [0, 23];","  },","","  /**","  * The start of the hour of the specified date.","  *","  * @param {Date} d: The specified date","  */","  start: function(d) {","    return d.hStart || (d.hStart = later.date.next(","      later.Y.val(d), later.M.val(d), later.D.val(d), later.h.val(d)));","  },","","  /**","  * The end of the hour of the specified date.","  *","  * @param {Date} d: The specified date","  */","  end: function(d) {","    return d.hEnd || (d.hEnd = later.date.prev(","      later.Y.val(d), later.M.val(d), later.D.val(d), later.h.val(d)));","  },","","  /**","  * Returns the start of the next instance of the hour value indicated.","  *","  * @param {Date} d: The starting date","  * @param {int} val: The desired value, must be within extent","  */","  next: function(d, val) {","    var next = later.date.next(","      later.Y.val(d),","      later.M.val(d),","      later.D.val(d) + (val &lt;= later.h.val(d) ? 1 : 0),","      val);","","    // correct for passing over a daylight savings boundry","    if(!later.date.isUTC &amp;&amp; next.getTime() &lt;= d.getTime()) {","      next = later.date.next(","        later.Y.val(next),","        later.M.val(next),","        later.D.val(next),","        val + 1);","    }","","    return next;","","  },","","  /**","  * Returns the end of the previous instance of the hour value indicated.","  *","  * @param {Date} d: The starting date","  * @param {int} val: The desired value, must be within extent","  */","  prev: function(d, val) {","    return later.date.prev(","      later.Y.val(d),","      later.M.val(d),","      later.D.val(d) + (val &gt;= later.h.val(d) ? -1 : 0),","      val);","  }","","};"];
_$jscoverage['constraint/hour.js'][11]++;
later.hour = (later.h = {name: "hour", range: 3600, val: (function (d) {
  _$jscoverage['constraint/hour.js'][30]++;
  return (d.h || (d.h = later.date.getHour.call(d)));
}), extent: (function () {
  _$jscoverage['constraint/hour.js'][37]++;
  return [0, 23];
}), start: (function (d) {
  _$jscoverage['constraint/hour.js'][46]++;
  return (d.hStart || (d.hStart = later.date.next(later.Y.val(d), later.M.val(d), later.D.val(d), later.h.val(d))));
}), end: (function (d) {
  _$jscoverage['constraint/hour.js'][56]++;
  return (d.hEnd || (d.hEnd = later.date.prev(later.Y.val(d), later.M.val(d), later.D.val(d), later.h.val(d))));
}), next: (function (d, val) {
  _$jscoverage['constraint/hour.js'][67]++;
  var next = later.date.next(later.Y.val(d), later.M.val(d), (later.D.val(d) + ((val <= later.h.val(d))? 1: 0)), val);
  _$jscoverage['constraint/hour.js'][74]++;
  if (((! later.date.isUTC) && (next.getTime() <= d.getTime()))) {
    _$jscoverage['constraint/hour.js'][75]++;
    next = later.date.next(later.Y.val(next), later.M.val(next), later.D.val(next), (val + 1));
  }
  _$jscoverage['constraint/hour.js'][82]++;
  return next;
}), prev: (function (d, val) {
  _$jscoverage['constraint/hour.js'][93]++;
  return later.date.prev(later.Y.val(d), later.M.val(d), (later.D.val(d) + ((val >= later.h.val(d))? -1: 0)), val);
})});
/* automatically generated by JSCoverage - do not edit */
try {
  if (typeof top === 'object' && top !== null && typeof top.opener === 'object' && top.opener !== null) {
    // this is a browser window that was opened from another window

    if (! top.opener._$jscoverage) {
      top.opener._$jscoverage = {};
    }
  }
}
catch (e) {}

try {
  if (typeof top === 'object' && top !== null) {
    // this is a browser window

    try {
      if (typeof top.opener === 'object' && top.opener !== null && top.opener._$jscoverage) {
        top._$jscoverage = top.opener._$jscoverage;
      }
    }
    catch (e) {}

    if (! top._$jscoverage) {
      top._$jscoverage = {};
    }
  }
}
catch (e) {}

try {
  if (typeof top === 'object' && top !== null && top._$jscoverage) {
    _$jscoverage = top._$jscoverage;
  }
}
catch (e) {}
if (typeof _$jscoverage !== 'object') {
  _$jscoverage = {};
}
if (! _$jscoverage['constraint/minute.js']) {
  _$jscoverage['constraint/minute.js'] = [];
  _$jscoverage['constraint/minute.js'][11] = 0;
  _$jscoverage['constraint/minute.js'][30] = 0;
  _$jscoverage['constraint/minute.js'][37] = 0;
  _$jscoverage['constraint/minute.js'][46] = 0;
  _$jscoverage['constraint/minute.js'][56] = 0;
  _$jscoverage['constraint/minute.js'][67] = 0;
  _$jscoverage['constraint/minute.js'][75] = 0;
  _$jscoverage['constraint/minute.js'][76] = 0;
  _$jscoverage['constraint/minute.js'][84] = 0;
  _$jscoverage['constraint/minute.js'][94] = 0;
}
_$jscoverage['constraint/minute.js'].source = ["/**","* Minute Constraint (m)","* (c) 2013 Bill, BunKat LLC.","*","* Definition for a minute constraint type.","*","* Later is freely distributable under the MIT license.","* For all details and documentation:","*     http://github.com/bunkat/later","*/","later.minute = later.m = {","","  /**","  * The name of this constraint.","  */","  name: 'minute',","","  /**","  * The rough amount of seconds between start and end for this constraint.","  * (doesn't need to be exact)","  */","  range: 60,","","  /**","  * The minute value of the specified date.","  *","  * @param {Date} d: The date to calculate the value of","  */","  val: function(d) {","    return d.m || (d.m = later.date.getMin.call(d));","  },","","  /**","  * The minimum and maximum valid minute values.","  */","  extent: function(d) {","    return [0, 59];","  },","","  /**","  * The start of the minute of the specified date.","  *","  * @param {Date} d: The specified date","  */","  start: function(d) {","    return d.mStart || (d.mStart = later.date.next(","      later.Y.val(d), later.M.val(d), later.D.val(d), later.h.val(d), later.m.val(d)));","  },","","  /**","  * The end of the minute of the specified date.","  *","  * @param {Date} d: The specified date","  */","  end: function(d) {","    return d.mEnd || (d.mEnd = later.date.prev(","      later.Y.val(d), later.M.val(d), later.D.val(d), later.h.val(d), later.m.val(d)));","  },","","  /**","  * Returns the start of the next instance of the minute value indicated.","  *","  * @param {Date} d: The starting date","  * @param {int} val: The desired value, must be within extent","  */","  next: function(d, val) {","    var next = later.date.next(","      later.Y.val(d),","      later.M.val(d),","      later.D.val(d),","      later.h.val(d) + (val &lt;= later.m.val(d) ? 1 : 0),","      val);","","    // correct for passing over a daylight savings boundry","    if(!later.date.isUTC &amp;&amp; next.getTime() &lt;= d.getTime()) {","      next = later.date.next(","        later.Y.val(next),","        later.M.val(next),","        later.D.val(next),","        later.h.val(next),","        val + 120);","    }","","    return next;","  },","","  /**","  * Returns the end of the previous instance of the minute value indicated.","  *","  * @param {Date} d: The starting date","  * @param {int} val: The desired value, must be within extent","  */","  prev: function(d, val) {","    return later.date.prev(","      later.Y.val(d),","      later.M.val(d),","      later.D.val(d),","      later.h.val(d) + (val &gt;= later.m.val(d) ? -1 : 0),","      val);","  }","","};"];
_$jscoverage['constraint/minute.js'][11]++;
later.minute = (later.m = {name: "minute", range: 60, val: (function (d) {
  _$jscoverage['constraint/minute.js'][30]++;
  return (d.m || (d.m = later.date.getMin.call(d)));
}), extent: (function (d) {
  _$jscoverage['constraint/minute.js'][37]++;
  return [0, 59];
}), start: (function (d) {
  _$jscoverage['constraint/minute.js'][46]++;
  return (d.mStart || (d.mStart = later.date.next(later.Y.val(d), later.M.val(d), later.D.val(d), later.h.val(d), later.m.val(d))));
}), end: (function (d) {
  _$jscoverage['constraint/minute.js'][56]++;
  return (d.mEnd || (d.mEnd = later.date.prev(later.Y.val(d), later.M.val(d), later.D.val(d), later.h.val(d), later.m.val(d))));
}), next: (function (d, val) {
  _$jscoverage['constraint/minute.js'][67]++;
  var next = later.date.next(later.Y.val(d), later.M.val(d), later.D.val(d), (later.h.val(d) + ((val <= later.m.val(d))? 1: 0)), val);
  _$jscoverage['constraint/minute.js'][75]++;
  if (((! later.date.isUTC) && (next.getTime() <= d.getTime()))) {
    _$jscoverage['constraint/minute.js'][76]++;
    next = later.date.next(later.Y.val(next), later.M.val(next), later.D.val(next), later.h.val(next), (val + 120));
  }
  _$jscoverage['constraint/minute.js'][84]++;
  return next;
}), prev: (function (d, val) {
  _$jscoverage['constraint/minute.js'][94]++;
  return later.date.prev(later.Y.val(d), later.M.val(d), later.D.val(d), (later.h.val(d) + ((val >= later.m.val(d))? -1: 0)), val);
})});
/* automatically generated by JSCoverage - do not edit */
try {
  if (typeof top === 'object' && top !== null && typeof top.opener === 'object' && top.opener !== null) {
    // this is a browser window that was opened from another window

    if (! top.opener._$jscoverage) {
      top.opener._$jscoverage = {};
    }
  }
}
catch (e) {}

try {
  if (typeof top === 'object' && top !== null) {
    // this is a browser window

    try {
      if (typeof top.opener === 'object' && top.opener !== null && top.opener._$jscoverage) {
        top._$jscoverage = top.opener._$jscoverage;
      }
    }
    catch (e) {}

    if (! top._$jscoverage) {
      top._$jscoverage = {};
    }
  }
}
catch (e) {}

try {
  if (typeof top === 'object' && top !== null && top._$jscoverage) {
    _$jscoverage = top._$jscoverage;
  }
}
catch (e) {}
if (typeof _$jscoverage !== 'object') {
  _$jscoverage = {};
}
if (! _$jscoverage['constraint/month.js']) {
  _$jscoverage['constraint/month.js'] = [];
  _$jscoverage['constraint/month.js'][11] = 0;
  _$jscoverage['constraint/month.js'][30] = 0;
  _$jscoverage['constraint/month.js'][38] = 0;
  _$jscoverage['constraint/month.js'][47] = 0;
  _$jscoverage['constraint/month.js'][56] = 0;
  _$jscoverage['constraint/month.js'][66] = 0;
  _$jscoverage['constraint/month.js'][78] = 0;
}
_$jscoverage['constraint/month.js'].source = ["/**","* Month Constraint (M)","* (c) 2013 Bill, BunKat LLC.","*","* Definition for a month constraint type.","*","* Later is freely distributable under the MIT license.","* For all details and documentation:","*     http://github.com/bunkat/later","*/","later.month = later.M = {","","  /**","  * The name of this constraint.","  */","  name: 'month',","","  /**","  * The rough amount of seconds between start and end for this constraint.","  * (doesn't need to be exact)","  */","  range: 2629740,","","  /**","  * The month value of the specified date.","  *","  * @param {Date} d: The date to calculate the value of","  */","  val: function(d) {","    return d.M || (d.M = later.date.getMonth.call(d)+1);","  },","","  /**","  * The minimum and maximum valid month values. Unlike the native date object,","  * month values in later are 1 based.","  */","  extent: function() {","    return [1, 12];","  },","","  /**","  * The start of the month of the specified date.","  *","  * @param {Date} d: The specified date","  */","  start: function(d) {","    return d.MStart || (d.MStart = later.date.next(later.Y.val(d), later.M.val(d)));","  },","","  /**","  * The end of the month of the specified date.","  *","  * @param {Date} d: The specified date","  */","  end: function(d) {","    return d.MEnd || (d.MEnd = later.date.prev(later.Y.val(d), later.M.val(d)));","  },","","  /**","  * Returns the start of the next instance of the month value indicated.","  *","  * @param {Date} d: The starting date","  * @param {int} val: The desired value, must be within extent","  */","  next: function(d, val) {","    return later.date.next(","      later.Y.val(d) + (val &lt;= later.M.val(d) ? 1 : 0),","      val);","  },","","  /**","  * Returns the end of the previous instance of the month value indicated.","  *","  * @param {Date} d: The starting date","  * @param {int} val: The desired value, must be within extent","  */","  prev: function(d, val) {","    return later.date.prev(","      later.Y.val(d) - (val &gt;= later.M.val(d) ? 1 : 0),","      val);","  }","","};"];
_$jscoverage['constraint/month.js'][11]++;
later.month = (later.M = {name: "month", range: 2629740, val: (function (d) {
  _$jscoverage['constraint/month.js'][30]++;
  return (d.M || (d.M = (later.date.getMonth.call(d) + 1)));
}), extent: (function () {
  _$jscoverage['constraint/month.js'][38]++;
  return [1, 12];
}), start: (function (d) {
  _$jscoverage['constraint/month.js'][47]++;
  return (d.MStart || (d.MStart = later.date.next(later.Y.val(d), later.M.val(d))));
}), end: (function (d) {
  _$jscoverage['constraint/month.js'][56]++;
  return (d.MEnd || (d.MEnd = later.date.prev(later.Y.val(d), later.M.val(d))));
}), next: (function (d, val) {
  _$jscoverage['constraint/month.js'][66]++;
  return later.date.next((later.Y.val(d) + ((val <= later.M.val(d))? 1: 0)), val);
}), prev: (function (d, val) {
  _$jscoverage['constraint/month.js'][78]++;
  return later.date.prev((later.Y.val(d) - ((val >= later.M.val(d))? 1: 0)), val);
})});
/* automatically generated by JSCoverage - do not edit */
try {
  if (typeof top === 'object' && top !== null && typeof top.opener === 'object' && top.opener !== null) {
    // this is a browser window that was opened from another window

    if (! top.opener._$jscoverage) {
      top.opener._$jscoverage = {};
    }
  }
}
catch (e) {}

try {
  if (typeof top === 'object' && top !== null) {
    // this is a browser window

    try {
      if (typeof top.opener === 'object' && top.opener !== null && top.opener._$jscoverage) {
        top._$jscoverage = top.opener._$jscoverage;
      }
    }
    catch (e) {}

    if (! top._$jscoverage) {
      top._$jscoverage = {};
    }
  }
}
catch (e) {}

try {
  if (typeof top === 'object' && top !== null && top._$jscoverage) {
    _$jscoverage = top._$jscoverage;
  }
}
catch (e) {}
if (typeof _$jscoverage !== 'object') {
  _$jscoverage = {};
}
if (! _$jscoverage['constraint/second.js']) {
  _$jscoverage['constraint/second.js'] = [];
  _$jscoverage['constraint/second.js'][11] = 0;
  _$jscoverage['constraint/second.js'][30] = 0;
  _$jscoverage['constraint/second.js'][37] = 0;
  _$jscoverage['constraint/second.js'][46] = 0;
  _$jscoverage['constraint/second.js'][55] = 0;
  _$jscoverage['constraint/second.js'][65] = 0;
  _$jscoverage['constraint/second.js'][74] = 0;
  _$jscoverage['constraint/second.js'][75] = 0;
  _$jscoverage['constraint/second.js'][84] = 0;
  _$jscoverage['constraint/second.js'][94] = 0;
}
_$jscoverage['constraint/second.js'].source = ["/**","* Second Constraint (s)","* (c) 2013 Bill, BunKat LLC.","*","* Definition for a second constraint type.","*","* Later is freely distributable under the MIT license.","* For all details and documentation:","*     http://github.com/bunkat/later","*/","later.second = later.s = {","","  /**","  * The name of this constraint.","  */","  name: 'second',","","  /**","  * The rough amount of seconds between start and end for this constraint.","  * (doesn't need to be exact)","  */","  range: 1,","","  /**","  * The second value of the specified date.","  *","  * @param {Date} d: The date to calculate the value of","  */","  val: function(d) {","    return d.s || (d.s = later.date.getSec.call(d));","  },","","  /**","  * The minimum and maximum valid second values.","  */","  extent: function() {","    return [0, 59];","  },","","  /**","  * The start of the second of the specified date.","  *","  * @param {Date} d: The specified date","  */","  start: function(d) {","    return d;","  },","","  /**","  * The end of the second of the specified date.","  *","  * @param {Date} d: The specified date","  */","  end: function(d) {","    return d;","  },","","  /**","  * Returns the start of the next instance of the second value indicated.","  *","  * @param {Date} d: The starting date","  * @param {int} val: The desired value, must be within extent","  */","  next: function(d, val) {","    var next = later.date.next(","      later.Y.val(d),","      later.M.val(d),","      later.D.val(d),","      later.h.val(d),","      later.m.val(d) + (val &lt;= later.s.val(d) ? 1 : 0),","      val);","","    // correct for passing over a daylight savings boundry","    if(!later.date.isUTC &amp;&amp; next.getTime() &lt;= d.getTime()) {","      next = later.date.next(","        later.Y.val(next),","        later.M.val(next),","        later.D.val(next),","        later.h.val(next),","        later.m.val(next),","        val + 7200);","    }","","    return next;","  },","","  /**","  * Returns the end of the previous instance of the second value indicated.","  *","  * @param {Date} d: The starting date","  * @param {int} val: The desired value, must be within extent","  */","  prev: function(d, val, cache) {","    return later.date.prev(","      later.Y.val(d),","      later.M.val(d),","      later.D.val(d),","      later.h.val(d),","      later.m.val(d) + (val &gt;= later.s.val(d) ? -1 : 0),","      val);","  }","","};"];
_$jscoverage['constraint/second.js'][11]++;
later.second = (later.s = {name: "second", range: 1, val: (function (d) {
  _$jscoverage['constraint/second.js'][30]++;
  return (d.s || (d.s = later.date.getSec.call(d)));
}), extent: (function () {
  _$jscoverage['constraint/second.js'][37]++;
  return [0, 59];
}), start: (function (d) {
  _$jscoverage['constraint/second.js'][46]++;
  return d;
}), end: (function (d) {
  _$jscoverage['constraint/second.js'][55]++;
  return d;
}), next: (function (d, val) {
  _$jscoverage['constraint/second.js'][65]++;
  var next = later.date.next(later.Y.val(d), later.M.val(d), later.D.val(d), later.h.val(d), (later.m.val(d) + ((val <= later.s.val(d))? 1: 0)), val);
  _$jscoverage['constraint/second.js'][74]++;
  if (((! later.date.isUTC) && (next.getTime() <= d.getTime()))) {
    _$jscoverage['constraint/second.js'][75]++;
    next = later.date.next(later.Y.val(next), later.M.val(next), later.D.val(next), later.h.val(next), later.m.val(next), (val + 7200));
  }
  _$jscoverage['constraint/second.js'][84]++;
  return next;
}), prev: (function (d, val, cache) {
  _$jscoverage['constraint/second.js'][94]++;
  return later.date.prev(later.Y.val(d), later.M.val(d), later.D.val(d), later.h.val(d), (later.m.val(d) + ((val >= later.s.val(d))? -1: 0)), val);
})});
/* automatically generated by JSCoverage - do not edit */
try {
  if (typeof top === 'object' && top !== null && typeof top.opener === 'object' && top.opener !== null) {
    // this is a browser window that was opened from another window

    if (! top.opener._$jscoverage) {
      top.opener._$jscoverage = {};
    }
  }
}
catch (e) {}

try {
  if (typeof top === 'object' && top !== null) {
    // this is a browser window

    try {
      if (typeof top.opener === 'object' && top.opener !== null && top.opener._$jscoverage) {
        top._$jscoverage = top.opener._$jscoverage;
      }
    }
    catch (e) {}

    if (! top._$jscoverage) {
      top._$jscoverage = {};
    }
  }
}
catch (e) {}

try {
  if (typeof top === 'object' && top !== null && top._$jscoverage) {
    _$jscoverage = top._$jscoverage;
  }
}
catch (e) {}
if (typeof _$jscoverage !== 'object') {
  _$jscoverage = {};
}
if (! _$jscoverage['constraint/time.js']) {
  _$jscoverage['constraint/time.js'] = [];
  _$jscoverage['constraint/time.js'][12] = 0;
  _$jscoverage['constraint/time.js'][31] = 0;
  _$jscoverage['constraint/time.js'][39] = 0;
  _$jscoverage['constraint/time.js'][48] = 0;
  _$jscoverage['constraint/time.js'][57] = 0;
  _$jscoverage['constraint/time.js'][67] = 0;
  _$jscoverage['constraint/time.js'][76] = 0;
  _$jscoverage['constraint/time.js'][77] = 0;
  _$jscoverage['constraint/time.js'][86] = 0;
  _$jscoverage['constraint/time.js'][96] = 0;
}
_$jscoverage['constraint/time.js'].source = ["/**","* Time Constraint (dy)","* (c) 2013 Bill, BunKat LLC.","*","* Definition for a time of day constraint type. Stored as number of seconds","* since midnight to simplify calculations.","*","* Later is freely distributable under the MIT license.","* For all details and documentation:","*     http://github.com/bunkat/later","*/","later.time = later.t = {","","  /**","  * The name of this constraint.","  */","  name: 'time',","","  /**","  * The rough amount of seconds between start and end for this constraint.","  * (doesn't need to be exact)","  */","  range: 86400,","","  /**","  * The time value of the specified date.","  *","  * @param {Date} d: The date to calculate the value of","  */","  val: function(d) {","    return d.t || (d.t =","      (later.h.val(d) * 3600) + (later.m.val(d) * 60) + (later.s.val(d)));","  },","","  /**","  * The minimum and maximum valid time values.","  */","  extent: function() {","    return [0, 86399];","  },","","  /**","  * Returns the specified date.","  *","  * @param {Date} d: The specified date","  */","  start: function(d) {","    return d;","  },","","  /**","  * Returns the specified date.","  *","  * @param {Date} d: The specified date","  */","  end: function(d) {","    return d;","  },","","  /**","  * Returns the start of the next instance of the time value indicated.","  *","  * @param {Date} d: The starting date","  * @param {int} val: The desired value, must be within extent","  */","  next: function(d, val) {","    var next = later.date.next(","      later.Y.val(d),","      later.M.val(d),","      later.D.val(d) + (val &lt;= later.t.val(d) ? 1 : 0),","      0,","      0,","      val);","","    // correct for passing over a daylight savings boundry","    if(!later.date.isUTC &amp;&amp; next.getTime() &lt; d.getTime()) {","      next = later.date.next(","        later.Y.val(next),","        later.M.val(next),","        later.D.val(next),","        later.h.val(next),","        later.m.val(next),","        val + 7200);","    }","","    return next;","  },","","  /**","  * Returns the end of the previous instance of the time value indicated.","  *","  * @param {Date} d: The starting date","  * @param {int} val: The desired value, must be within extent","  */","  prev: function(d, val) {","    return later.date.next(","      later.Y.val(d),","      later.M.val(d),","      later.D.val(d) + (val &gt;= later.t.val(d) ? -1 : 0),","      0,","      0,","      val);","  }","","};"];
_$jscoverage['constraint/time.js'][12]++;
later.time = (later.t = {name: "time", range: 86400, val: (function (d) {
  _$jscoverage['constraint/time.js'][31]++;
  return (d.t || (d.t = ((later.h.val(d) * 3600) + (later.m.val(d) * 60) + later.s.val(d))));
}), extent: (function () {
  _$jscoverage['constraint/time.js'][39]++;
  return [0, 86399];
}), start: (function (d) {
  _$jscoverage['constraint/time.js'][48]++;
  return d;
}), end: (function (d) {
  _$jscoverage['constraint/time.js'][57]++;
  return d;
}), next: (function (d, val) {
  _$jscoverage['constraint/time.js'][67]++;
  var next = later.date.next(later.Y.val(d), later.M.val(d), (later.D.val(d) + ((val <= later.t.val(d))? 1: 0)), 0, 0, val);
  _$jscoverage['constraint/time.js'][76]++;
  if (((! later.date.isUTC) && (next.getTime() < d.getTime()))) {
    _$jscoverage['constraint/time.js'][77]++;
    next = later.date.next(later.Y.val(next), later.M.val(next), later.D.val(next), later.h.val(next), later.m.val(next), (val + 7200));
  }
  _$jscoverage['constraint/time.js'][86]++;
  return next;
}), prev: (function (d, val) {
  _$jscoverage['constraint/time.js'][96]++;
  return later.date.next(later.Y.val(d), later.M.val(d), (later.D.val(d) + ((val >= later.t.val(d))? -1: 0)), 0, 0, val);
})});
/* automatically generated by JSCoverage - do not edit */
try {
  if (typeof top === 'object' && top !== null && typeof top.opener === 'object' && top.opener !== null) {
    // this is a browser window that was opened from another window

    if (! top.opener._$jscoverage) {
      top.opener._$jscoverage = {};
    }
  }
}
catch (e) {}

try {
  if (typeof top === 'object' && top !== null) {
    // this is a browser window

    try {
      if (typeof top.opener === 'object' && top.opener !== null && top.opener._$jscoverage) {
        top._$jscoverage = top.opener._$jscoverage;
      }
    }
    catch (e) {}

    if (! top._$jscoverage) {
      top._$jscoverage = {};
    }
  }
}
catch (e) {}

try {
  if (typeof top === 'object' && top !== null && top._$jscoverage) {
    _$jscoverage = top._$jscoverage;
  }
}
catch (e) {}
if (typeof _$jscoverage !== 'object') {
  _$jscoverage = {};
}
if (! _$jscoverage['constraint/weekofmonth.js']) {
  _$jscoverage['constraint/weekofmonth.js'] = [];
  _$jscoverage['constraint/weekofmonth.js'][13] = 0;
  _$jscoverage['constraint/weekofmonth.js'][32] = 0;
  _$jscoverage['constraint/weekofmonth.js'][44] = 0;
  _$jscoverage['constraint/weekofmonth.js'][55] = 0;
  _$jscoverage['constraint/weekofmonth.js'][67] = 0;
  _$jscoverage['constraint/weekofmonth.js'][82] = 0;
  _$jscoverage['constraint/weekofmonth.js'][85] = 0;
  _$jscoverage['constraint/weekofmonth.js'][88] = 0;
  _$jscoverage['constraint/weekofmonth.js'][103] = 0;
  _$jscoverage['constraint/weekofmonth.js'][106] = 0;
  _$jscoverage['constraint/weekofmonth.js'][109] = 0;
}
_$jscoverage['constraint/weekofmonth.js'].source = ["/**","* Week of Month Constraint (wy)","* (c) 2013 Bill, BunKat LLC.","*","* Definition for an week of month constraint type. Week of month treats the","* first of the month as the start of week 1, with each following week starting","* on Sunday.","*","* Later is freely distributable under the MIT license.","* For all details and documentation:","*     http://github.com/bunkat/later","*/","later.weekOfMonth = later.wm = {","","  /**","  * The name of this constraint.","  */","  name: 'week of month',","","  /**","  * The rough amount of seconds between start and end for this constraint.","  * (doesn't need to be exact)","  */","  range: 604800,","","  /**","  * The week of month value of the specified date.","  *","  * @param {Date} d: The date to calculate the value of","  */","  val: function(d) {","    return d.wm || (d.wm =","      (later.D.val(d) +","      (later.dw.val(later.M.start(d)) - 1) + (7 - later.dw.val(d))) / 7);","  },","","  /**","  * The minimum and maximum valid week of month values for the month indicated.","  * Zero indicates the last week in the month.","  *","  * @param {Date} d: The date indicating the month to find values for","  */","  extent: function(d) {","    return d.wmExtent || (d.wmExtent = [1,","      (later.D.extent(d)[1] + (later.dw.val(later.M.start(d)) - 1) +","      (7 - later.dw.val(later.M.end(d)))) / 7]);","  },","","  /**","  * The start of the week of the specified date.","  *","  * @param {Date} d: The specified date","  */","  start: function(d) {","    return d.wmStart || (d.wmStart = later.date.next(","      later.Y.val(d),","      later.M.val(d),","      Math.max(later.D.val(d) - later.dw.val(d) + 1, 1)));","  },","","  /**","  * The end of the week of the specified date.","  *","  * @param {Date} d: The specified date","  */","  end: function(d) {","    return d.wmEnd || (d.wmEnd = later.date.prev(","      later.Y.val(d),","      later.M.val(d),","      Math.min(later.D.val(d) + (7 - later.dw.val(d)), later.D.extent(d)[1])));","  },","","  /**","  * Returns the start of the next instance of the week value indicated. Returns","  * the first day of the next month if val is greater than the number of","  * days in the following month.","  *","  * @param {Date} d: The starting date","  * @param {int} val: The desired value, must be within extent","  */","  next: function(d, val) {","    var month = later.date.nextRollover(d, val, later.wm, later.M),","        wmMax = later.wm.extent(month)[1];","","    val = val &gt; wmMax ? 1 : val;","","    // jump to the Sunday of the desired week, set to 1st of month for week 1","    return later.date.next(","        later.Y.val(month),","        later.M.val(month),","        Math.max(1, (val-1) * 7 - (later.dw.val(month)-2)));","  },","","  /**","  * Returns the end of the previous instance of the week value indicated. Returns","  * the last day of the previous month if val is greater than the number of","  * days in the previous month.","  *","  * @param {Date} d: The starting date","  * @param {int} val: The desired value, must be within extent","  */","  prev: function(d, val) {","    var month = later.date.prevRollover(d, val, later.wm, later.M),","        wmMax = later.wm.extent(month)[1];","","    val = val &gt; wmMax ? wmMax : val;","","    // jump to the end of Saturday of the desired week","    return later.wm.end(later.date.next(","        later.Y.val(month),","        later.M.val(month),","        Math.max(1, (val-1) * 7 - (later.dw.val(month)-2))));","  }","","};"];
_$jscoverage['constraint/weekofmonth.js'][13]++;
later.weekOfMonth = (later.wm = {name: "week of month", range: 604800, val: (function (d) {
  _$jscoverage['constraint/weekofmonth.js'][32]++;
  return (d.wm || (d.wm = ((later.D.val(d) + (later.dw.val(later.M.start(d)) - 1) + (7 - later.dw.val(d))) / 7)));
}), extent: (function (d) {
  _$jscoverage['constraint/weekofmonth.js'][44]++;
  return (d.wmExtent || (d.wmExtent = [1, ((later.D.extent(d)[1] + (later.dw.val(later.M.start(d)) - 1) + (7 - later.dw.val(later.M.end(d)))) / 7)]));
}), start: (function (d) {
  _$jscoverage['constraint/weekofmonth.js'][55]++;
  return (d.wmStart || (d.wmStart = later.date.next(later.Y.val(d), later.M.val(d), Math.max(((later.D.val(d) - later.dw.val(d)) + 1), 1))));
}), end: (function (d) {
  _$jscoverage['constraint/weekofmonth.js'][67]++;
  return (d.wmEnd || (d.wmEnd = later.date.prev(later.Y.val(d), later.M.val(d), Math.min((later.D.val(d) + (7 - later.dw.val(d))), later.D.extent(d)[1]))));
}), next: (function (d, val) {
  _$jscoverage['constraint/weekofmonth.js'][82]++;
  var month = later.date.nextRollover(d, val, later.wm, later.M), wmMax = later.wm.extent(month)[1];
  _$jscoverage['constraint/weekofmonth.js'][85]++;
  val = ((val > wmMax)? 1: val);
  _$jscoverage['constraint/weekofmonth.js'][88]++;
  return later.date.next(later.Y.val(month), later.M.val(month), Math.max(1, (((val - 1) * 7) - (later.dw.val(month) - 2))));
}), prev: (function (d, val) {
  _$jscoverage['constraint/weekofmonth.js'][103]++;
  var month = later.date.prevRollover(d, val, later.wm, later.M), wmMax = later.wm.extent(month)[1];
  _$jscoverage['constraint/weekofmonth.js'][106]++;
  val = ((val > wmMax)? wmMax: val);
  _$jscoverage['constraint/weekofmonth.js'][109]++;
  return later.wm.end(later.date.next(later.Y.val(month), later.M.val(month), Math.max(1, (((val - 1) * 7) - (later.dw.val(month) - 2)))));
})});
/* automatically generated by JSCoverage - do not edit */
try {
  if (typeof top === 'object' && top !== null && typeof top.opener === 'object' && top.opener !== null) {
    // this is a browser window that was opened from another window

    if (! top.opener._$jscoverage) {
      top.opener._$jscoverage = {};
    }
  }
}
catch (e) {}

try {
  if (typeof top === 'object' && top !== null) {
    // this is a browser window

    try {
      if (typeof top.opener === 'object' && top.opener !== null && top.opener._$jscoverage) {
        top._$jscoverage = top.opener._$jscoverage;
      }
    }
    catch (e) {}

    if (! top._$jscoverage) {
      top._$jscoverage = {};
    }
  }
}
catch (e) {}

try {
  if (typeof top === 'object' && top !== null && top._$jscoverage) {
    _$jscoverage = top._$jscoverage;
  }
}
catch (e) {}
if (typeof _$jscoverage !== 'object') {
  _$jscoverage = {};
}
if (! _$jscoverage['constraint/weekofyear.js']) {
  _$jscoverage['constraint/weekofyear.js'] = [];
  _$jscoverage['constraint/weekofyear.js'][12] = 0;
  _$jscoverage['constraint/weekofyear.js'][31] = 0;
  _$jscoverage['constraint/weekofyear.js'][34] = 0;
  _$jscoverage['constraint/weekofyear.js'][38] = 0;
  _$jscoverage['constraint/weekofyear.js'][47] = 0;
  _$jscoverage['constraint/weekofyear.js'][50] = 0;
  _$jscoverage['constraint/weekofyear.js'][54] = 0;
  _$jscoverage['constraint/weekofyear.js'][63] = 0;
  _$jscoverage['constraint/weekofyear.js'][77] = 0;
  _$jscoverage['constraint/weekofyear.js'][92] = 0;
  _$jscoverage['constraint/weekofyear.js'][96] = 0;
  _$jscoverage['constraint/weekofyear.js'][97] = 0;
  _$jscoverage['constraint/weekofyear.js'][100] = 0;
  _$jscoverage['constraint/weekofyear.js'][103] = 0;
  _$jscoverage['constraint/weekofyear.js'][105] = 0;
  _$jscoverage['constraint/weekofyear.js'][119] = 0;
  _$jscoverage['constraint/weekofyear.js'][123] = 0;
  _$jscoverage['constraint/weekofyear.js'][124] = 0;
  _$jscoverage['constraint/weekofyear.js'][127] = 0;
  _$jscoverage['constraint/weekofyear.js'][130] = 0;
  _$jscoverage['constraint/weekofyear.js'][132] = 0;
}
_$jscoverage['constraint/weekofyear.js'].source = ["/**","* Week of Year Constraint (wy)","* (c) 2013 Bill, BunKat LLC.","*","* Definition for an ISO 8601 week constraint type. For more information about","* ISO 8601 see http://en.wikipedia.org/wiki/ISO_week_date.","*","* Later is freely distributable under the MIT license.","* For all details and documentation:","*     http://github.com/bunkat/later","*/","later.weekOfYear = later.wy = {","","  /**","  * The name of this constraint.","  */","  name: 'week of year (ISO)',","","  /**","  * The rough amount of seconds between start and end for this constraint.","  * (doesn't need to be exact)","  */","  range: 604800,","","  /**","  * The ISO week year value of the specified date.","  *","  * @param {Date} d: The date to calculate the value of","  */","  val: function(d) {","    if (d.wy) return d.wy;","","    // move to the Thursday in the target week and find Thurs of target year","    var wThur = later.dw.next(later.wy.start(d), 5),","        YThur = later.dw.next(later.Y.prev(wThur, later.Y.val(wThur)-1), 5);","","    // caculate the difference between the two dates in weeks","    return (d.wy = 1 + Math.ceil((wThur.getTime() - YThur.getTime()) / later.WEEK));","  },","","  /**","  * The minimum and maximum valid ISO week values for the year indicated.","  *","  * @param {Date} d: The date indicating the year to find ISO values for","  */","  extent: function(d) {","    if (d.wyExtent) return d.wyExtent;","","    // go to start of ISO week to get to the right year","    var year = later.dw.next(later.wy.start(d), 5),","        dwFirst = later.dw.val(later.Y.start(year)),","        dwLast = later.dw.val(later.Y.end(year));","","    return (d.wyExtent = [1, dwFirst === 5 || dwLast === 5 ? 53 : 52]);","  },","","  /**","  * The start of the ISO week of the specified date.","  *","  * @param {Date} d: The specified date","  */","  start: function(d) {","    return d.wyStart || (d.wyStart = later.date.next(","      later.Y.val(d),","      later.M.val(d),","      // jump to the Monday of the current week","      later.D.val(d) - (later.dw.val(d) &gt; 1 ? later.dw.val(d) - 2 : 6)","    ));","  },","","  /**","  * The end of the ISO week of the specified date.","  *","  * @param {Date} d: The specified date","  */","  end: function(d) {","    return d.wyEnd || (d.wyEnd = later.date.prev(","      later.Y.val(d),","      later.M.val(d),","      // jump to the Saturday of the current week","      later.D.val(d) + (later.dw.val(d) &gt; 1 ? 8 - later.dw.val(d) : 0)","    ));","  },","","  /**","  * Returns the start of the next instance of the ISO week value indicated.","  *","  * @param {Date} d: The starting date","  * @param {int} val: The desired value, must be within extent","  */","  next: function(d, val) {","    var wyThur = later.dw.next(later.wy.start(d), 5),","        year = later.date.nextRollover(wyThur, val, later.wy, later.Y);","","    // handle case where 1st of year is last week of previous month","    if(later.wy.val(year) !== 1) {","      year = later.dw.next(year, 2);","    }","","    var wyMax = later.wy.extent(year)[1],","        wyStart = later.wy.start(year);","","    val = val &gt; wyMax ? 1 : val;","","    return later.date.next(","        later.Y.val(wyStart),","        later.M.val(wyStart),","        later.D.val(wyStart) + 7 * (val-1)","      );","  },","","  /**","  * Returns the end of the previous instance of the ISO week value indicated.","  *","  * @param {Date} d: The starting date","  * @param {int} val: The desired value, must be within extent","  */","  prev: function(d, val) {","    var wyThur = later.dw.next(later.wy.start(d), 5),","        year = later.date.prevRollover(wyThur, val, later.wy, later.Y);","","    // handle case where 1st of year is last week of previous month","    if(later.wy.val(year) !== 1) {","      year = later.dw.next(year, 2);","    }","","    var wyMax = later.wy.extent(year)[1],","        wyEnd = later.wy.end(year);","","    val = val &gt; wyMax ? wyMax : val;","","    return later.wy.end(later.date.next(","        later.Y.val(wyEnd),","        later.M.val(wyEnd),","        later.D.val(wyEnd) + 7 * (val-1)","      ));","  }","};"];
_$jscoverage['constraint/weekofyear.js'][12]++;
later.weekOfYear = (later.wy = {name: "week of year (ISO)", range: 604800, val: (function (d) {
  _$jscoverage['constraint/weekofyear.js'][31]++;
  if (d.wy) {
    _$jscoverage['constraint/weekofyear.js'][31]++;
    return d.wy;
  }
  _$jscoverage['constraint/weekofyear.js'][34]++;
  var wThur = later.dw.next(later.wy.start(d), 5), YThur = later.dw.next(later.Y.prev(wThur, (later.Y.val(wThur) - 1)), 5);
  _$jscoverage['constraint/weekofyear.js'][38]++;
  return (d.wy = (1 + Math.ceil(((wThur.getTime() - YThur.getTime()) / later.WEEK))));
}), extent: (function (d) {
  _$jscoverage['constraint/weekofyear.js'][47]++;
  if (d.wyExtent) {
    _$jscoverage['constraint/weekofyear.js'][47]++;
    return d.wyExtent;
  }
  _$jscoverage['constraint/weekofyear.js'][50]++;
  var year = later.dw.next(later.wy.start(d), 5), dwFirst = later.dw.val(later.Y.start(year)), dwLast = later.dw.val(later.Y.end(year));
  _$jscoverage['constraint/weekofyear.js'][54]++;
  return (d.wyExtent = [1, (((dwFirst === 5) || (dwLast === 5))? 53: 52)]);
}), start: (function (d) {
  _$jscoverage['constraint/weekofyear.js'][63]++;
  return (d.wyStart || (d.wyStart = later.date.next(later.Y.val(d), later.M.val(d), (later.D.val(d) - ((later.dw.val(d) > 1)? (later.dw.val(d) - 2): 6)))));
}), end: (function (d) {
  _$jscoverage['constraint/weekofyear.js'][77]++;
  return (d.wyEnd || (d.wyEnd = later.date.prev(later.Y.val(d), later.M.val(d), (later.D.val(d) + ((later.dw.val(d) > 1)? (8 - later.dw.val(d)): 0)))));
}), next: (function (d, val) {
  _$jscoverage['constraint/weekofyear.js'][92]++;
  var wyThur = later.dw.next(later.wy.start(d), 5), year = later.date.nextRollover(wyThur, val, later.wy, later.Y);
  _$jscoverage['constraint/weekofyear.js'][96]++;
  if ((later.wy.val(year) !== 1)) {
    _$jscoverage['constraint/weekofyear.js'][97]++;
    year = later.dw.next(year, 2);
  }
  _$jscoverage['constraint/weekofyear.js'][100]++;
  var wyMax = later.wy.extent(year)[1], wyStart = later.wy.start(year);
  _$jscoverage['constraint/weekofyear.js'][103]++;
  val = ((val > wyMax)? 1: val);
  _$jscoverage['constraint/weekofyear.js'][105]++;
  return later.date.next(later.Y.val(wyStart), later.M.val(wyStart), (later.D.val(wyStart) + (7 * (val - 1))));
}), prev: (function (d, val) {
  _$jscoverage['constraint/weekofyear.js'][119]++;
  var wyThur = later.dw.next(later.wy.start(d), 5), year = later.date.prevRollover(wyThur, val, later.wy, later.Y);
  _$jscoverage['constraint/weekofyear.js'][123]++;
  if ((later.wy.val(year) !== 1)) {
    _$jscoverage['constraint/weekofyear.js'][124]++;
    year = later.dw.next(year, 2);
  }
  _$jscoverage['constraint/weekofyear.js'][127]++;
  var wyMax = later.wy.extent(year)[1], wyEnd = later.wy.end(year);
  _$jscoverage['constraint/weekofyear.js'][130]++;
  val = ((val > wyMax)? wyMax: val);
  _$jscoverage['constraint/weekofyear.js'][132]++;
  return later.wy.end(later.date.next(later.Y.val(wyEnd), later.M.val(wyEnd), (later.D.val(wyEnd) + (7 * (val - 1)))));
})});
/* automatically generated by JSCoverage - do not edit */
try {
  if (typeof top === 'object' && top !== null && typeof top.opener === 'object' && top.opener !== null) {
    // this is a browser window that was opened from another window

    if (! top.opener._$jscoverage) {
      top.opener._$jscoverage = {};
    }
  }
}
catch (e) {}

try {
  if (typeof top === 'object' && top !== null) {
    // this is a browser window

    try {
      if (typeof top.opener === 'object' && top.opener !== null && top.opener._$jscoverage) {
        top._$jscoverage = top.opener._$jscoverage;
      }
    }
    catch (e) {}

    if (! top._$jscoverage) {
      top._$jscoverage = {};
    }
  }
}
catch (e) {}

try {
  if (typeof top === 'object' && top !== null && top._$jscoverage) {
    _$jscoverage = top._$jscoverage;
  }
}
catch (e) {}
if (typeof _$jscoverage !== 'object') {
  _$jscoverage = {};
}
if (! _$jscoverage['constraint/year.js']) {
  _$jscoverage['constraint/year.js'] = [];
  _$jscoverage['constraint/year.js'][11] = 0;
  _$jscoverage['constraint/year.js'][30] = 0;
  _$jscoverage['constraint/year.js'][39] = 0;
  _$jscoverage['constraint/year.js'][48] = 0;
  _$jscoverage['constraint/year.js'][57] = 0;
  _$jscoverage['constraint/year.js'][67] = 0;
  _$jscoverage['constraint/year.js'][77] = 0;
}
_$jscoverage['constraint/year.js'].source = ["/**","* Year Constraint (Y)","* (c) 2013 Bill, BunKat LLC.","*","* Definition for a year constraint type.","*","* Later is freely distributable under the MIT license.","* For all details and documentation:","*     http://github.com/bunkat/later","*/","later.year = later.Y = {","","  /**","  * The name of this constraint.","  */","  name: 'year',","","  /**","  * The rough amount of seconds between start and end for this constraint.","  * (doesn't need to be exact)","  */","  range: 31556900,","","  /**","  * The year value of the specified date.","  *","  * @param {Date} d: The date to calculate the value of","  */","  val: function(d) {","    return d.Y || (d.Y = later.date.getYear.call(d));","  },","","  /**","  * The minimum and maximum valid values for the year constraint.","  * If max is past 2099, later.D.extent must be fixed to calculate leap years","  * correctly.","  */","  extent: function() {","    return [1970, 2099];","  },","","  /**","  * The start of the year of the specified date.","  *","  * @param {Date} d: The specified date","  */","  start: function(d) {","    return d.YStart || (d.YStart = later.date.next(later.Y.val(d)));","  },","","  /**","  * The end of the year of the specified date.","  *","  * @param {Date} d: The specified date","  */","  end: function(d) {","    return d.YEnd || (d.YEnd = later.date.prev(later.Y.val(d)));","  },","","  /**","  * Returns the start of the next instance of the year value indicated.","  *","  * @param {Date} d: The starting date","  * @param {int} val: The desired value, must be within extent","  */","  next: function(d, val) {","    return val &gt; later.Y.val(d) ? later.date.next(val) : undefined;","  },","","  /**","  * Returns the end of the previous instance of the year value indicated.","  *","  * @param {Date} d: The starting date","  * @param {int} val: The desired value, must be within extent","  */","  prev: function(d, val) {","    return val &lt; later.Y.val(d) ? later.date.prev(val) : undefined;","  }","","};"];
_$jscoverage['constraint/year.js'][11]++;
later.year = (later.Y = {name: "year", range: 31556900, val: (function (d) {
  _$jscoverage['constraint/year.js'][30]++;
  return (d.Y || (d.Y = later.date.getYear.call(d)));
}), extent: (function () {
  _$jscoverage['constraint/year.js'][39]++;
  return [1970, 2099];
}), start: (function (d) {
  _$jscoverage['constraint/year.js'][48]++;
  return (d.YStart || (d.YStart = later.date.next(later.Y.val(d))));
}), end: (function (d) {
  _$jscoverage['constraint/year.js'][57]++;
  return (d.YEnd || (d.YEnd = later.date.prev(later.Y.val(d))));
}), next: (function (d, val) {
  _$jscoverage['constraint/year.js'][67]++;
  return ((val > later.Y.val(d))? later.date.next(val): undefined);
}), prev: (function (d, val) {
  _$jscoverage['constraint/year.js'][77]++;
  return ((val < later.Y.val(d))? later.date.prev(val): undefined);
})});
/* automatically generated by JSCoverage - do not edit */
try {
  if (typeof top === 'object' && top !== null && typeof top.opener === 'object' && top.opener !== null) {
    // this is a browser window that was opened from another window

    if (! top.opener._$jscoverage) {
      top.opener._$jscoverage = {};
    }
  }
}
catch (e) {}

try {
  if (typeof top === 'object' && top !== null) {
    // this is a browser window

    try {
      if (typeof top.opener === 'object' && top.opener !== null && top.opener._$jscoverage) {
        top._$jscoverage = top.opener._$jscoverage;
      }
    }
    catch (e) {}

    if (! top._$jscoverage) {
      top._$jscoverage = {};
    }
  }
}
catch (e) {}

try {
  if (typeof top === 'object' && top !== null && top._$jscoverage) {
    _$jscoverage = top._$jscoverage;
  }
}
catch (e) {}
if (typeof _$jscoverage !== 'object') {
  _$jscoverage = {};
}
if (! _$jscoverage['modifier/modifier.js']) {
  _$jscoverage['modifier/modifier.js'] = [];
  _$jscoverage['modifier/modifier.js'][2] = 0;
}
_$jscoverage['modifier/modifier.js'].source = ["","later.modifier = {};"];
_$jscoverage['modifier/modifier.js'][2]++;
later.modifier = {};

/* automatically generated by JSCoverage - do not edit */
try {
  if (typeof top === 'object' && top !== null && typeof top.opener === 'object' && top.opener !== null) {
    // this is a browser window that was opened from another window

    if (! top.opener._$jscoverage) {
      top.opener._$jscoverage = {};
    }
  }
}
catch (e) {}

try {
  if (typeof top === 'object' && top !== null) {
    // this is a browser window

    try {
      if (typeof top.opener === 'object' && top.opener !== null && top.opener._$jscoverage) {
        top._$jscoverage = top.opener._$jscoverage;
      }
    }
    catch (e) {}

    if (! top._$jscoverage) {
      top._$jscoverage = {};
    }
  }
}
catch (e) {}

try {
  if (typeof top === 'object' && top !== null && top._$jscoverage) {
    _$jscoverage = top._$jscoverage;
  }
}
catch (e) {}
if (typeof _$jscoverage !== 'object') {
  _$jscoverage = {};
}
if (! _$jscoverage['modifier/after.js']) {
  _$jscoverage['modifier/after.js'] = [];
  _$jscoverage['modifier/after.js'][19] = 0;
  _$jscoverage['modifier/after.js'][21] = 0;
  _$jscoverage['modifier/after.js'][40] = 0;
  _$jscoverage['modifier/after.js'][41] = 0;
  _$jscoverage['modifier/after.js'][63] = 0;
  _$jscoverage['modifier/after.js'][64] = 0;
  _$jscoverage['modifier/after.js'][71] = 0;
  _$jscoverage['modifier/after.js'][72] = 0;
}
_$jscoverage['modifier/after.js'].source = ["/**","* After Modifier","* (c) 2013 Bill, BunKat LLC.","*","* Modifies a constraint such that all values that are greater than the","* specified value are considered valid.","*","* Later is freely distributable under the MIT license.","* For all details and documentation:","*     http://github.com/bunkat/later","*/","","/**","* Creates a new modified constraint.","*","* @param {Constraint} constraint: The constraint to be modified","* @param {Integer} value: The starting value of the after constraint","*/","later.modifier.after = later.modifier.a = function(constraint, value) {","","  return {","","    /**","    * Returns the name of the constraint with the 'after' modifier.","    */","    name: 'after ' + constraint.name,","","    /**","    * Pass through to the constraint.","    */","    range: constraint.range,","","    /**","    * The value of the specified date. Returns value for any constraint val","    * that is greater than or equal to value.","    *","    * @param {Date} d: The date to calculate the value of","    */","    val: function(d) {","      var cVal = constraint.val(d);","      return cVal &gt;= value ? value : cVal;","    },","","    /**","    * Pass through to the constraint.","    */","    extent: constraint.extent,","","    /**","    * Pass through to the constraint.","    */","    start: constraint.start,","","    /**","    * Pass through to the constraint.","    */","    end: constraint.end,","","    /**","    * Pass through to the constraint.","    */","    next: function(startDate, val) {","        if(val &gt; value) val = constraint.extent(startDate)[0];","        return constraint.next(startDate, val);","    },","","    /**","    * Pass through to the constraint.","    */","    prev: function(startDate, val) {","        if(val &gt;= value) val = constraint.extent(startDate)[1];","        return constraint.prev(startDate, val);","    }","","  };","","};"];
_$jscoverage['modifier/after.js'][19]++;
later.modifier.after = (later.modifier.a = (function (constraint, value) {
  _$jscoverage['modifier/after.js'][21]++;
  return ({name: ("after " + constraint.name), range: constraint.range, val: (function (d) {
  _$jscoverage['modifier/after.js'][40]++;
  var cVal = constraint.val(d);
  _$jscoverage['modifier/after.js'][41]++;
  return ((cVal >= value)? value: cVal);
}), extent: constraint.extent, start: constraint.start, end: constraint.end, next: (function (startDate, val) {
  _$jscoverage['modifier/after.js'][63]++;
  if ((val > value)) {
    _$jscoverage['modifier/after.js'][63]++;
    val = constraint.extent(startDate)[0];
  }
  _$jscoverage['modifier/after.js'][64]++;
  return constraint.next(startDate, val);
}), prev: (function (startDate, val) {
  _$jscoverage['modifier/after.js'][71]++;
  if ((val >= value)) {
    _$jscoverage['modifier/after.js'][71]++;
    val = constraint.extent(startDate)[1];
  }
  _$jscoverage['modifier/after.js'][72]++;
  return constraint.prev(startDate, val);
})});
}));
/* automatically generated by JSCoverage - do not edit */
try {
  if (typeof top === 'object' && top !== null && typeof top.opener === 'object' && top.opener !== null) {
    // this is a browser window that was opened from another window

    if (! top.opener._$jscoverage) {
      top.opener._$jscoverage = {};
    }
  }
}
catch (e) {}

try {
  if (typeof top === 'object' && top !== null) {
    // this is a browser window

    try {
      if (typeof top.opener === 'object' && top.opener !== null && top.opener._$jscoverage) {
        top._$jscoverage = top.opener._$jscoverage;
      }
    }
    catch (e) {}

    if (! top._$jscoverage) {
      top._$jscoverage = {};
    }
  }
}
catch (e) {}

try {
  if (typeof top === 'object' && top !== null && top._$jscoverage) {
    _$jscoverage = top._$jscoverage;
  }
}
catch (e) {}
if (typeof _$jscoverage !== 'object') {
  _$jscoverage = {};
}
if (! _$jscoverage['modifier/before.js']) {
  _$jscoverage['modifier/before.js'] = [];
  _$jscoverage['modifier/before.js'][19] = 0;
  _$jscoverage['modifier/before.js'][21] = 0;
  _$jscoverage['modifier/before.js'][40] = 0;
  _$jscoverage['modifier/before.js'][41] = 0;
  _$jscoverage['modifier/before.js'][63] = 0;
  _$jscoverage['modifier/before.js'][64] = 0;
  _$jscoverage['modifier/before.js'][71] = 0;
  _$jscoverage['modifier/before.js'][72] = 0;
}
_$jscoverage['modifier/before.js'].source = ["/**","* Before Modifier","* (c) 2013 Bill, BunKat LLC.","*","* Modifies a constraint such that all values that are less than the","* specified value are considered valid.","*","* Later is freely distributable under the MIT license.","* For all details and documentation:","*     http://github.com/bunkat/later","*/","","/**","* Creates a new modified constraint.","*","* @param {Constraint} constraint: The constraint to be modified","* @param {Integer} value: The starting value of the before constraint","*/","later.modifier.before = later.modifier.b = function(constraint, value) {","","  return {","","    /**","    * Returns the name of the constraint with the 'before' modifier.","    */","    name: 'before ' + constraint.name,","","    /**","    * Pass through to the constraint.","    */","    range: constraint.range,","","    /**","    * The value of the specified date. Returns value for any constraint val","    * that is less than or equal to value.","    *","    * @param {Date} d: The date to calculate the value of","    */","    val: function(d) {","      var cVal = constraint.val(d);","      return cVal &lt;= value ? value : cVal;","    },","","    /**","    * Pass through to the constraint.","    */","    extent: constraint.extent,","","    /**","    * Pass through to the constraint.","    */","    start: constraint.start,","","    /**","    * Pass through to the constraint.","    */","    end: constraint.end,","","    /**","    * Pass through to the constraint.","    */","    next: function(startDate, val) {","        if(val &lt;= value) val = constraint.extent(startDate)[0];","        return constraint.next(startDate, val);","    },","","    /**","    * Pass through to the constraint.","    */","    prev: function(startDate, val) {","        if(val &lt; value) val = constraint.extent(startDate)[1];","        return constraint.prev(startDate, val);","    }","","  };","","};"];
_$jscoverage['modifier/before.js'][19]++;
later.modifier.before = (later.modifier.b = (function (constraint, value) {
  _$jscoverage['modifier/before.js'][21]++;
  return ({name: ("before " + constraint.name), range: constraint.range, val: (function (d) {
  _$jscoverage['modifier/before.js'][40]++;
  var cVal = constraint.val(d);
  _$jscoverage['modifier/before.js'][41]++;
  return ((cVal <= value)? value: cVal);
}), extent: constraint.extent, start: constraint.start, end: constraint.end, next: (function (startDate, val) {
  _$jscoverage['modifier/before.js'][63]++;
  if ((val <= value)) {
    _$jscoverage['modifier/before.js'][63]++;
    val = constraint.extent(startDate)[0];
  }
  _$jscoverage['modifier/before.js'][64]++;
  return constraint.next(startDate, val);
}), prev: (function (startDate, val) {
  _$jscoverage['modifier/before.js'][71]++;
  if ((val < value)) {
    _$jscoverage['modifier/before.js'][71]++;
    val = constraint.extent(startDate)[1];
  }
  _$jscoverage['modifier/before.js'][72]++;
  return constraint.prev(startDate, val);
})});
}));
/* automatically generated by JSCoverage - do not edit */
try {
  if (typeof top === 'object' && top !== null && typeof top.opener === 'object' && top.opener !== null) {
    // this is a browser window that was opened from another window

    if (! top.opener._$jscoverage) {
      top.opener._$jscoverage = {};
    }
  }
}
catch (e) {}

try {
  if (typeof top === 'object' && top !== null) {
    // this is a browser window

    try {
      if (typeof top.opener === 'object' && top.opener !== null && top.opener._$jscoverage) {
        top._$jscoverage = top.opener._$jscoverage;
      }
    }
    catch (e) {}

    if (! top._$jscoverage) {
      top._$jscoverage = {};
    }
  }
}
catch (e) {}

try {
  if (typeof top === 'object' && top !== null && top._$jscoverage) {
    _$jscoverage = top._$jscoverage;
  }
}
catch (e) {}
if (typeof _$jscoverage !== 'object') {
  _$jscoverage = {};
}
if (! _$jscoverage['core/compile.js']) {
  _$jscoverage['core/compile.js'] = [];
  _$jscoverage['core/compile.js'][13] = 0;
  _$jscoverage['core/compile.js'][15] = 0;
  _$jscoverage['core/compile.js'][19] = 0;
  _$jscoverage['core/compile.js'][20] = 0;
  _$jscoverage['core/compile.js'][26] = 0;
  _$jscoverage['core/compile.js'][27] = 0;
  _$jscoverage['core/compile.js'][33] = 0;
  _$jscoverage['core/compile.js'][34] = 0;
  _$jscoverage['core/compile.js'][38] = 0;
  _$jscoverage['core/compile.js'][40] = 0;
  _$jscoverage['core/compile.js'][41] = 0;
  _$jscoverage['core/compile.js'][42] = 0;
  _$jscoverage['core/compile.js'][43] = 0;
  _$jscoverage['core/compile.js'][46] = 0;
  _$jscoverage['core/compile.js'][56] = 0;
  _$jscoverage['core/compile.js'][60] = 0;
  _$jscoverage['core/compile.js'][61] = 0;
  _$jscoverage['core/compile.js'][65] = 0;
  _$jscoverage['core/compile.js'][66] = 0;
  _$jscoverage['core/compile.js'][72] = 0;
  _$jscoverage['core/compile.js'][73] = 0;
  _$jscoverage['core/compile.js'][74] = 0;
  _$jscoverage['core/compile.js'][75] = 0;
  _$jscoverage['core/compile.js'][80] = 0;
  _$jscoverage['core/compile.js'][92] = 0;
  _$jscoverage['core/compile.js'][94] = 0;
  _$jscoverage['core/compile.js'][98] = 0;
  _$jscoverage['core/compile.js'][99] = 0;
  _$jscoverage['core/compile.js'][106] = 0;
  _$jscoverage['core/compile.js'][107] = 0;
  _$jscoverage['core/compile.js'][109] = 0;
  _$jscoverage['core/compile.js'][110] = 0;
  _$jscoverage['core/compile.js'][113] = 0;
  _$jscoverage['core/compile.js'][114] = 0;
  _$jscoverage['core/compile.js'][118] = 0;
  _$jscoverage['core/compile.js'][128] = 0;
}
_$jscoverage['core/compile.js'].source = ["/**","* Compile","* (c) 2013 Bill, BunKat LLC.","*","* Compiles a schedule definition into a form from which instances can be","* efficiently calculated from.","*","* Later is freely distributable under the MIT license.","* For all details and documentation:","*     http://github.com/bunkat/later","*/","","later.compile = function(schedDef) {","","  var constraints = [],","      constraintsLen = 0,","      tickConstraint;","","  for(var key in schedDef) {","    var nameParts = key.split('_'),","        name = nameParts[0],","        mod = nameParts[1],","        vals = schedDef[key],","        constraint = mod ? later.modifier[mod](later[name], vals[0]) : later[name];","","    constraints.push({constraint: constraint, vals: vals});","    constraintsLen++;","  }","","  // sort constraints based on their range for best performance (we want to","  // always skip the largest block of time possible to find the next valid","  // value)","  constraints.sort(function(a,b) {","    return a.constraint.range &lt; b.constraint.range;","  });","","  // this is the smallest constraint which we will use to tick this schedule","  tickConstraint = constraints[constraintsLen-1].constraint;","","  function compareFn(dir) {","    return dir === 'next' ?","      function(a,b) { return a &gt; b; } :","      function(a,b) { return b &gt; a; };","  }","","  return {","","    /**","    * Calculates the start of the next valid occurrence of a particular schedule","    * that occurs on or after the specified start time.","    *","    * @param {String} dir: Direction to search in ('next' or 'prev')","    * @param {Date} startDate: The first possible valid occurrence","    */","    start: function(dir, startDate) {","      var next = startDate,","          nextVal = later.array[dir],","          done = false;","","      while(!done &amp;&amp; next) {","        done = true;","","        // verify all of the constraints in order since we want to make the","        // largest jumps possible to find the first valid value","        for(var i = 0; i &lt; constraintsLen; i++) {","          var constraint = constraints[i].constraint,","              curVal = constraint.val(next),","              vals = constraints[i].vals,","              extent = constraint.extent(next),","              newVal = nextVal(curVal, vals, extent);","","          if(curVal !== newVal) {","            next = constraint[dir](next, newVal);","            done = false;","            break;","          }","        }","      }","","      return next ? tickConstraint.start(next) : undefined;","    },","","    /**","    * Given a valid start time, finds the next schedule that is invalid.","    * Returns the start time if it is actually invalid. Useful for finding the","    * end of a valid time range.","    *","    * @param {String} dir: Direction to search in ('next' or 'prev')","    * @param {Date} startDate: The first possible valid occurrence","    */","    end: function(dir, startDate) {","      dir = 'next';","","      var nextInvalidVal = later.array[dir + 'Invalid'],","          compare = compareFn(dir),","          result;","","      for(var i = constraintsLen-1; i &gt;= 0; i--) {","        var constraint = constraints[i].constraint,","            curVal = constraint.val(startDate),","            vals = constraints[i].vals,","            extent = constraint.extent(startDate),","            nextVal = nextInvalidVal(curVal, vals, extent),","            next;","","        if(nextVal === curVal) { // startDate is invalid, use that","          next = startDate;","        }","        else if(nextVal) { // constraint has invalid value, use that","          next = constraint[dir](startDate, nextVal);","        }","","        if(next &amp;&amp; (!result || compare(result, next))) {","          result = next;","        }","      }","","      return result;","    },","","    /**","    * Ticks the date by the minimum constraint in this schedule","    *","    * @param {String} dir: Direction to search in ('next' or 'prev')","    * @param {Date} date: The start date to tick from","    */","    tick: function(dir, date) {","      return new Date(dir === 'next' ?","        tickConstraint.end(date).getTime() + later.SEC :","        tickConstraint.start(date).getTime() - later.SEC);","    }","","  };","};"];
_$jscoverage['core/compile.js'][13]++;
later.compile = (function (schedDef) {
  _$jscoverage['core/compile.js'][15]++;
  var constraints = [], constraintsLen = 0, tickConstraint;
  _$jscoverage['core/compile.js'][19]++;
  for (var key in schedDef) {
    _$jscoverage['core/compile.js'][20]++;
    var nameParts = key.split("_"), name = nameParts[0], mod = nameParts[1], vals = schedDef[key], constraint = (mod? (later.modifier[mod])(later[name], vals[0]): later[name]);
    _$jscoverage['core/compile.js'][26]++;
    constraints.push({constraint: constraint, vals: vals});
    _$jscoverage['core/compile.js'][27]++;
    (constraintsLen++);
}
  _$jscoverage['core/compile.js'][33]++;
  constraints.sort((function (a, b) {
  _$jscoverage['core/compile.js'][34]++;
  return (a.constraint.range < b.constraint.range);
}));
  _$jscoverage['core/compile.js'][38]++;
  tickConstraint = constraints[(constraintsLen - 1)].constraint;
  _$jscoverage['core/compile.js'][40]++;
  function compareFn(dir) {
    _$jscoverage['core/compile.js'][41]++;
    return ((dir === "next")? (function (a, b) {
  _$jscoverage['core/compile.js'][42]++;
  return (a > b);
}): (function (a, b) {
  _$jscoverage['core/compile.js'][43]++;
  return (b > a);
}));
}
  _$jscoverage['core/compile.js'][46]++;
  return ({start: (function (dir, startDate) {
  _$jscoverage['core/compile.js'][56]++;
  var next = startDate, nextVal = later.array[dir], done = false;
  _$jscoverage['core/compile.js'][60]++;
  while (((! done) && next)) {
    _$jscoverage['core/compile.js'][61]++;
    done = true;
    _$jscoverage['core/compile.js'][65]++;
    for (var i = 0; (i < constraintsLen); (i++)) {
      _$jscoverage['core/compile.js'][66]++;
      var constraint = constraints[i].constraint, curVal = constraint.val(next), vals = constraints[i].vals, extent = constraint.extent(next), newVal = nextVal(curVal, vals, extent);
      _$jscoverage['core/compile.js'][72]++;
      if ((curVal !== newVal)) {
        _$jscoverage['core/compile.js'][73]++;
        next = (constraint[dir])(next, newVal);
        _$jscoverage['core/compile.js'][74]++;
        done = false;
        _$jscoverage['core/compile.js'][75]++;
        break;
      }
}
}
  _$jscoverage['core/compile.js'][80]++;
  return (next? tickConstraint.start(next): undefined);
}), end: (function (dir, startDate) {
  _$jscoverage['core/compile.js'][92]++;
  dir = "next";
  _$jscoverage['core/compile.js'][94]++;
  var nextInvalidVal = later.array[(dir + "Invalid")], compare = compareFn(dir), result;
  _$jscoverage['core/compile.js'][98]++;
  for (var i = (constraintsLen - 1); (i >= 0); (i--)) {
    _$jscoverage['core/compile.js'][99]++;
    var constraint = constraints[i].constraint, curVal = constraint.val(startDate), vals = constraints[i].vals, extent = constraint.extent(startDate), nextVal = nextInvalidVal(curVal, vals, extent), next;
    _$jscoverage['core/compile.js'][106]++;
    if ((nextVal === curVal)) {
      _$jscoverage['core/compile.js'][107]++;
      next = startDate;
    }
    else {
      _$jscoverage['core/compile.js'][109]++;
      if (nextVal) {
        _$jscoverage['core/compile.js'][110]++;
        next = (constraint[dir])(startDate, nextVal);
      }
    }
    _$jscoverage['core/compile.js'][113]++;
    if ((next && ((! result) || compare(result, next)))) {
      _$jscoverage['core/compile.js'][114]++;
      result = next;
    }
}
  _$jscoverage['core/compile.js'][118]++;
  return result;
}), tick: (function (dir, date) {
  _$jscoverage['core/compile.js'][128]++;
  return new Date(((dir === "next")? (tickConstraint.end(date).getTime() + later.SEC): (tickConstraint.start(date).getTime() - later.SEC)));
})});
});
/* automatically generated by JSCoverage - do not edit */
try {
  if (typeof top === 'object' && top !== null && typeof top.opener === 'object' && top.opener !== null) {
    // this is a browser window that was opened from another window

    if (! top.opener._$jscoverage) {
      top.opener._$jscoverage = {};
    }
  }
}
catch (e) {}

try {
  if (typeof top === 'object' && top !== null) {
    // this is a browser window

    try {
      if (typeof top.opener === 'object' && top.opener !== null && top.opener._$jscoverage) {
        top._$jscoverage = top.opener._$jscoverage;
      }
    }
    catch (e) {}

    if (! top._$jscoverage) {
      top._$jscoverage = {};
    }
  }
}
catch (e) {}

try {
  if (typeof top === 'object' && top !== null && top._$jscoverage) {
    _$jscoverage = top._$jscoverage;
  }
}
catch (e) {}
if (typeof _$jscoverage !== 'object') {
  _$jscoverage = {};
}
if (! _$jscoverage['core/schedule.js']) {
  _$jscoverage['core/schedule.js'] = [];
  _$jscoverage['core/schedule.js'][13] = 0;
  _$jscoverage['core/schedule.js'][16] = 0;
  _$jscoverage['core/schedule.js'][19] = 0;
  _$jscoverage['core/schedule.js'][20] = 0;
  _$jscoverage['core/schedule.js'][23] = 0;
  _$jscoverage['core/schedule.js'][24] = 0;
  _$jscoverage['core/schedule.js'][27] = 0;
  _$jscoverage['core/schedule.js'][28] = 0;
  _$jscoverage['core/schedule.js'][31] = 0;
  _$jscoverage['core/schedule.js'][35] = 0;
  _$jscoverage['core/schedule.js'][36] = 0;
  _$jscoverage['core/schedule.js'][40] = 0;
  _$jscoverage['core/schedule.js'][42] = 0;
  _$jscoverage['core/schedule.js'][44] = 0;
  _$jscoverage['core/schedule.js'][47] = 0;
  _$jscoverage['core/schedule.js'][48] = 0;
  _$jscoverage['core/schedule.js'][49] = 0;
  _$jscoverage['core/schedule.js'][54] = 0;
  _$jscoverage['core/schedule.js'][55] = 0;
  _$jscoverage['core/schedule.js'][56] = 0;
  _$jscoverage['core/schedule.js'][57] = 0;
  _$jscoverage['core/schedule.js'][61] = 0;
  _$jscoverage['core/schedule.js'][66] = 0;
  _$jscoverage['core/schedule.js'][68] = 0;
  _$jscoverage['core/schedule.js'][72] = 0;
  _$jscoverage['core/schedule.js'][73] = 0;
  _$jscoverage['core/schedule.js'][77] = 0;
  _$jscoverage['core/schedule.js'][81] = 0;
  _$jscoverage['core/schedule.js'][82] = 0;
  _$jscoverage['core/schedule.js'][84] = 0;
  _$jscoverage['core/schedule.js'][86] = 0;
  _$jscoverage['core/schedule.js'][87] = 0;
  _$jscoverage['core/schedule.js'][88] = 0;
  _$jscoverage['core/schedule.js'][89] = 0;
  _$jscoverage['core/schedule.js'][95] = 0;
  _$jscoverage['core/schedule.js'][96] = 0;
  _$jscoverage['core/schedule.js'][97] = 0;
  _$jscoverage['core/schedule.js'][98] = 0;
  _$jscoverage['core/schedule.js'][102] = 0;
  _$jscoverage['core/schedule.js'][105] = 0;
  _$jscoverage['core/schedule.js'][106] = 0;
  _$jscoverage['core/schedule.js'][107] = 0;
  _$jscoverage['core/schedule.js'][108] = 0;
  _$jscoverage['core/schedule.js'][109] = 0;
  _$jscoverage['core/schedule.js'][110] = 0;
  _$jscoverage['core/schedule.js'][112] = 0;
  _$jscoverage['core/schedule.js'][113] = 0;
  _$jscoverage['core/schedule.js'][118] = 0;
  _$jscoverage['core/schedule.js'][121] = 0;
  _$jscoverage['core/schedule.js'][122] = 0;
  _$jscoverage['core/schedule.js'][123] = 0;
  _$jscoverage['core/schedule.js'][124] = 0;
  _$jscoverage['core/schedule.js'][129] = 0;
  _$jscoverage['core/schedule.js'][130] = 0;
  _$jscoverage['core/schedule.js'][132] = 0;
  _$jscoverage['core/schedule.js'][133] = 0;
  _$jscoverage['core/schedule.js'][134] = 0;
  _$jscoverage['core/schedule.js'][139] = 0;
  _$jscoverage['core/schedule.js'][140] = 0;
  _$jscoverage['core/schedule.js'][141] = 0;
  _$jscoverage['core/schedule.js'][142] = 0;
  _$jscoverage['core/schedule.js'][145] = 0;
  _$jscoverage['core/schedule.js'][146] = 0;
  _$jscoverage['core/schedule.js'][150] = 0;
  _$jscoverage['core/schedule.js'][153] = 0;
  _$jscoverage['core/schedule.js'][157] = 0;
  _$jscoverage['core/schedule.js'][161] = 0;
  _$jscoverage['core/schedule.js'][165] = 0;
  _$jscoverage['core/schedule.js'][169] = 0;
}
_$jscoverage['core/schedule.js'].source = ["/**","* Schedule","* (c) 2013 Bill, BunKat LLC.","*","* Returns an object to calculate future or previous occurrences of the","* specified schedule.","*","* Later is freely distributable under the MIT license.","* For all details and documentation:","*     http://github.com/bunkat/later","*/","","later.schedule = function(sched) {","","  // compile the schedule components","  var schedules = [], schedulesLen = sched.schedules.length,","      exceptions = [], exceptionsLen = sched.exceptions ? sched.exceptions.length : 0;","","  for(var i = 0; i &lt; schedulesLen; i++) {","    schedules.push(later.compile(sched.schedules[i]));","  }","","  for(var j = 0; j &lt; exceptionsLen; j++) {","    exceptions.push(later.compile(sched.exceptions[j]));","  }","","  function getInstances(dir, count, startDate, endDate, isRange) {","    var d = startDate ? new Date(startDate) : new Date(),","        instances = getStart(dir, count, d, endDate, isRange);","","    return instances.length === 0 ? undefined :","           count === 1 ? instances[0] : instances;","  }","","  function getStart(dir, count, startDate, endDate, isRange) {","    var nextIndex = indexFn(dir), compare = compareFn(dir),","        schedStarts = [], next, results = [];","","    // calc the earliest start date for each schedule","    calcSchedStarts(dir, schedStarts, startDate);","","    while(count--) {","","      while((next = schedStarts[nextIndex(schedStarts)])) {","","        // make sure we didn't go past the end date","        if((endDate &amp;&amp; compare(next.getTime(), endDate.getTime()))) {","          next = null;","          break;","        }","","        // make sure that this date isn't included in any exception","        // if it is, update the schedule starts and try again","        var exceptionEnd = getExceptionEnd(dir, next);","        if(exceptionEnd) {","          calcSchedStarts(dir, schedStarts, exceptionEnd);","          continue;","        }","","        // date is good, push to results and tick schedules to next time","        results.push( isRange ?","          [new Date(next), new Date(getEnd(dir, schedStarts, next))] :","           new Date(next)","        );","","        tickSchedStarts(dir, schedStarts, next);","","        break;","      }","","      // break out if we've run out of valid dates","      if(!next) {","        break;","      }","    }","","    return results;","  }","","","  function getEnd(dir, schedStarts, next) {","    var compare = compareFn(dir), end;","","    for(var i = 0; i &lt; schedulesLen; i++) {","      // find the max end date for any schedule that is valid at 'next'","      if(schedStarts[i] &amp;&amp; schedStarts[i].getTime() === next.getTime()) {","        var schedEnd = schedules[i].end(dir, next);","        if(!end || compare(schedEnd,end)) {","          end = schedEnd;","        }","      }","    }","","    // find the min start date of any exception starting from 'next'","    for(var j = 0; j &lt; exceptionsLen; j++) {","      var exceptStart = exceptions[j].start(dir, next);","      if(compare(end, exceptStart)) {","        end = exceptStart;","      }","    }","","    return new Date(end);","  }","","  function getExceptionEnd(dir, next) {","    var compare = compareFn(dir), result;","    if(exceptionsLen) {","      for(var i = 0; i &lt; exceptionsLen; i++) {","        var exceptStart = exceptions[i].start(dir, next);","        if(exceptStart &amp;&amp; (exceptStart.getTime() === next.getTime() || compare(next, exceptStart))) {","          //var end = exceptions[i].end(dir, next);","          var end = dir === 'next' ? exceptions[i].end(dir, next) : new Date(exceptStart.getTime()-1000);","          result = !result || compare(end, result) ? end : result;","        }","      }","    }","","    return result;","  }","","  function tickSchedStarts(dir, schedStarts, next) {","    for(var i = 0; i &lt; schedulesLen; i++) {","      if(schedStarts[i] &amp;&amp; schedStarts[i].getTime() === next.getTime()) {","        schedStarts[i] = schedules[i].start(dir, schedules[i].tick(dir, next));","      }","    }","  }","","  function calcSchedStarts(dir, schedStarts, next) {","    var compare = compareFn(dir);","","    for(var i = 0; i &lt; schedulesLen; i++) {","      if(!schedStarts[i] || compare(next, schedStarts[i])) {","        schedStarts[i] = schedules[i].start(dir, next);","      }","    }","  }","","  function compareFn(dir) {","    return dir === 'next' ?","      function(a,b) { return a &gt; b; } :","      function(a,b) { return b &gt; a; };","  }","","  function indexFn(dir) {","    return dir === 'next' ? later.array.minIndex : later.array.maxIndex;","  }","","","  return {","","    isValid: function(d) {","      return getInstances('next', 1, d, d) !== undefined;","    },","","    next: function(count, startDate, endDate) {","      return getInstances('next', count || 1, startDate, endDate);","    },","","    prev: function(count, startDate, endDate) {","      return getInstances('prev', count || 1, startDate, endDate);","    },","","    nextRange: function(count, startDate, endDate) {","      return getInstances('next', count || 1, startDate, endDate, true);","    },","","    prevRange: function(count, startDate, endDate) {","      return getInstances('prev', count || 1, startDate, endDate, true);","    }","","  };","","};"];
_$jscoverage['core/schedule.js'][13]++;
later.schedule = (function (sched) {
  _$jscoverage['core/schedule.js'][16]++;
  var schedules = [], schedulesLen = sched.schedules.length, exceptions = [], exceptionsLen = (sched.exceptions? sched.exceptions.length: 0);
  _$jscoverage['core/schedule.js'][19]++;
  for (var i = 0; (i < schedulesLen); (i++)) {
    _$jscoverage['core/schedule.js'][20]++;
    schedules.push(later.compile(sched.schedules[i]));
}
  _$jscoverage['core/schedule.js'][23]++;
  for (var j = 0; (j < exceptionsLen); (j++)) {
    _$jscoverage['core/schedule.js'][24]++;
    exceptions.push(later.compile(sched.exceptions[j]));
}
  _$jscoverage['core/schedule.js'][27]++;
  function getInstances(dir, count, startDate, endDate, isRange) {
    _$jscoverage['core/schedule.js'][28]++;
    var d = (startDate? new Date(startDate): new Date()), instances = getStart(dir, count, d, endDate, isRange);
    _$jscoverage['core/schedule.js'][31]++;
    return ((instances.length === 0)? undefined: ((count === 1)? instances[0]: instances));
}
  _$jscoverage['core/schedule.js'][35]++;
  function getStart(dir, count, startDate, endDate, isRange) {
    _$jscoverage['core/schedule.js'][36]++;
    var nextIndex = indexFn(dir), compare = compareFn(dir), schedStarts = [], next, results = [];
    _$jscoverage['core/schedule.js'][40]++;
    calcSchedStarts(dir, schedStarts, startDate);
    _$jscoverage['core/schedule.js'][42]++;
    while ((count--)) {
      _$jscoverage['core/schedule.js'][44]++;
      while ((next = schedStarts[nextIndex(schedStarts)])) {
        _$jscoverage['core/schedule.js'][47]++;
        if ((endDate && compare(next.getTime(), endDate.getTime()))) {
          _$jscoverage['core/schedule.js'][48]++;
          next = null;
          _$jscoverage['core/schedule.js'][49]++;
          break;
        }
        _$jscoverage['core/schedule.js'][54]++;
        var exceptionEnd = getExceptionEnd(dir, next);
        _$jscoverage['core/schedule.js'][55]++;
        if (exceptionEnd) {
          _$jscoverage['core/schedule.js'][56]++;
          calcSchedStarts(dir, schedStarts, exceptionEnd);
          _$jscoverage['core/schedule.js'][57]++;
          continue;
        }
        _$jscoverage['core/schedule.js'][61]++;
        results.push((isRange? [new Date(next), new Date(getEnd(dir, schedStarts, next))]: new Date(next)));
        _$jscoverage['core/schedule.js'][66]++;
        tickSchedStarts(dir, schedStarts, next);
        _$jscoverage['core/schedule.js'][68]++;
        break;
}
      _$jscoverage['core/schedule.js'][72]++;
      if ((! next)) {
        _$jscoverage['core/schedule.js'][73]++;
        break;
      }
}
    _$jscoverage['core/schedule.js'][77]++;
    return results;
}
  _$jscoverage['core/schedule.js'][81]++;
  function getEnd(dir, schedStarts, next) {
    _$jscoverage['core/schedule.js'][82]++;
    var compare = compareFn(dir), end;
    _$jscoverage['core/schedule.js'][84]++;
    for (var i = 0; (i < schedulesLen); (i++)) {
      _$jscoverage['core/schedule.js'][86]++;
      if ((schedStarts[i] && (schedStarts[i].getTime() === next.getTime()))) {
        _$jscoverage['core/schedule.js'][87]++;
        var schedEnd = schedules[i].end(dir, next);
        _$jscoverage['core/schedule.js'][88]++;
        if (((! end) || compare(schedEnd, end))) {
          _$jscoverage['core/schedule.js'][89]++;
          end = schedEnd;
        }
      }
}
    _$jscoverage['core/schedule.js'][95]++;
    for (var j = 0; (j < exceptionsLen); (j++)) {
      _$jscoverage['core/schedule.js'][96]++;
      var exceptStart = exceptions[j].start(dir, next);
      _$jscoverage['core/schedule.js'][97]++;
      if (compare(end, exceptStart)) {
        _$jscoverage['core/schedule.js'][98]++;
        end = exceptStart;
      }
}
    _$jscoverage['core/schedule.js'][102]++;
    return new Date(end);
}
  _$jscoverage['core/schedule.js'][105]++;
  function getExceptionEnd(dir, next) {
    _$jscoverage['core/schedule.js'][106]++;
    var compare = compareFn(dir), result;
    _$jscoverage['core/schedule.js'][107]++;
    if (exceptionsLen) {
      _$jscoverage['core/schedule.js'][108]++;
      for (var i = 0; (i < exceptionsLen); (i++)) {
        _$jscoverage['core/schedule.js'][109]++;
        var exceptStart = exceptions[i].start(dir, next);
        _$jscoverage['core/schedule.js'][110]++;
        if ((exceptStart && ((exceptStart.getTime() === next.getTime()) || compare(next, exceptStart)))) {
          _$jscoverage['core/schedule.js'][112]++;
          var end = ((dir === "next")? exceptions[i].end(dir, next): new Date((exceptStart.getTime() - 1000)));
          _$jscoverage['core/schedule.js'][113]++;
          result = (((! result) || compare(end, result))? end: result);
        }
}
    }
    _$jscoverage['core/schedule.js'][118]++;
    return result;
}
  _$jscoverage['core/schedule.js'][121]++;
  function tickSchedStarts(dir, schedStarts, next) {
    _$jscoverage['core/schedule.js'][122]++;
    for (var i = 0; (i < schedulesLen); (i++)) {
      _$jscoverage['core/schedule.js'][123]++;
      if ((schedStarts[i] && (schedStarts[i].getTime() === next.getTime()))) {
        _$jscoverage['core/schedule.js'][124]++;
        schedStarts[i] = schedules[i].start(dir, schedules[i].tick(dir, next));
      }
}
}
  _$jscoverage['core/schedule.js'][129]++;
  function calcSchedStarts(dir, schedStarts, next) {
    _$jscoverage['core/schedule.js'][130]++;
    var compare = compareFn(dir);
    _$jscoverage['core/schedule.js'][132]++;
    for (var i = 0; (i < schedulesLen); (i++)) {
      _$jscoverage['core/schedule.js'][133]++;
      if (((! schedStarts[i]) || compare(next, schedStarts[i]))) {
        _$jscoverage['core/schedule.js'][134]++;
        schedStarts[i] = schedules[i].start(dir, next);
      }
}
}
  _$jscoverage['core/schedule.js'][139]++;
  function compareFn(dir) {
    _$jscoverage['core/schedule.js'][140]++;
    return ((dir === "next")? (function (a, b) {
  _$jscoverage['core/schedule.js'][141]++;
  return (a > b);
}): (function (a, b) {
  _$jscoverage['core/schedule.js'][142]++;
  return (b > a);
}));
}
  _$jscoverage['core/schedule.js'][145]++;
  function indexFn(dir) {
    _$jscoverage['core/schedule.js'][146]++;
    return ((dir === "next")? later.array.minIndex: later.array.maxIndex);
}
  _$jscoverage['core/schedule.js'][150]++;
  return ({isValid: (function (d) {
  _$jscoverage['core/schedule.js'][153]++;
  return (getInstances("next", 1, d, d) !== undefined);
}), next: (function (count, startDate, endDate) {
  _$jscoverage['core/schedule.js'][157]++;
  return getInstances("next", (count || 1), startDate, endDate);
}), prev: (function (count, startDate, endDate) {
  _$jscoverage['core/schedule.js'][161]++;
  return getInstances("prev", (count || 1), startDate, endDate);
}), nextRange: (function (count, startDate, endDate) {
  _$jscoverage['core/schedule.js'][165]++;
  return getInstances("next", (count || 1), startDate, endDate, true);
}), prevRange: (function (count, startDate, endDate) {
  _$jscoverage['core/schedule.js'][169]++;
  return getInstances("prev", (count || 1), startDate, endDate, true);
})});
});
/* automatically generated by JSCoverage - do not edit */
try {
  if (typeof top === 'object' && top !== null && typeof top.opener === 'object' && top.opener !== null) {
    // this is a browser window that was opened from another window

    if (! top.opener._$jscoverage) {
      top.opener._$jscoverage = {};
    }
  }
}
catch (e) {}

try {
  if (typeof top === 'object' && top !== null) {
    // this is a browser window

    try {
      if (typeof top.opener === 'object' && top.opener !== null && top.opener._$jscoverage) {
        top._$jscoverage = top.opener._$jscoverage;
      }
    }
    catch (e) {}

    if (! top._$jscoverage) {
      top._$jscoverage = {};
    }
  }
}
catch (e) {}

try {
  if (typeof top === 'object' && top !== null && top._$jscoverage) {
    _$jscoverage = top._$jscoverage;
  }
}
catch (e) {}
if (typeof _$jscoverage !== 'object') {
  _$jscoverage = {};
}
if (! _$jscoverage['date/date.js']) {
  _$jscoverage['date/date.js'] = [];
  _$jscoverage['date/date.js'][1] = 0;
  _$jscoverage['date/date.js'][3] = 0;
  _$jscoverage['date/date.js'][5] = 0;
  _$jscoverage['date/date.js'][6] = 0;
  _$jscoverage['date/date.js'][9] = 0;
  _$jscoverage['date/date.js'][10] = 0;
  _$jscoverage['date/date.js'][11] = 0;
  _$jscoverage['date/date.js'][12] = 0;
  _$jscoverage['date/date.js'][13] = 0;
  _$jscoverage['date/date.js'][14] = 0;
  _$jscoverage['date/date.js'][15] = 0;
  _$jscoverage['date/date.js'][16] = 0;
  _$jscoverage['date/date.js'][19] = 0;
  _$jscoverage['date/date.js'][21] = 0;
  _$jscoverage['date/date.js'][22] = 0;
  _$jscoverage['date/date.js'][25] = 0;
  _$jscoverage['date/date.js'][26] = 0;
  _$jscoverage['date/date.js'][27] = 0;
  _$jscoverage['date/date.js'][28] = 0;
  _$jscoverage['date/date.js'][29] = 0;
  _$jscoverage['date/date.js'][30] = 0;
  _$jscoverage['date/date.js'][31] = 0;
  _$jscoverage['date/date.js'][32] = 0;
  _$jscoverage['date/date.js'][36] = 0;
  _$jscoverage['date/date.js'][38] = 0;
  _$jscoverage['date/date.js'][39] = 0;
  _$jscoverage['date/date.js'][53] = 0;
  _$jscoverage['date/date.js'][54] = 0;
  _$jscoverage['date/date.js'][65] = 0;
}
_$jscoverage['date/date.js'].source = ["later.date = {};","","later.date.UTC = function() {","","  later.date.build = function(Y, M, D, h, m, s) {","    return new Date(Date.UTC(Y, M, D, h, m, s));","  };","","  later.date.isUTC = true;","  later.date.getYear = Date.prototype.getUTCFullYear;","  later.date.getMonth = Date.prototype.getUTCMonth;","  later.date.getDate = Date.prototype.getUTCDate;","  later.date.getDay = Date.prototype.getUTCDay;","  later.date.getHour = Date.prototype.getUTCHours;","  later.date.getMin = Date.prototype.getUTCMinutes;","  later.date.getSec = Date.prototype.getUTCSeconds;","};","","later.date.localTime = function() {","","  later.date.build = function(Y, M, D, h, m, s) {","    return new Date(Y, M, D, h, m, s);","  };","","  later.date.isUTC = false;","  later.date.getYear = Date.prototype.getFullYear;","  later.date.getMonth = Date.prototype.getMonth;","  later.date.getDate = Date.prototype.getDate;","  later.date.getDay = Date.prototype.getDay;","  later.date.getHour = Date.prototype.getHours;","  later.date.getMin = Date.prototype.getMinutes;","  later.date.getSec = Date.prototype.getSeconds;","};","","// utc by default","later.date.UTC();","","later.date.nextRollover = function(d, val, constraint, period) {","  return val &lt;= constraint.val(d) || val &gt; constraint.extent(d)[1] ?","            period.next(d, period.val(d)+1) :","            period.start(d);","","","/*  return (val &amp;&amp; val &lt;= constraint.val(d)) ||","         (val &gt; constraint.extent(d)[1]) ||","         (!val &amp;&amp; constraint.val(d) === constraint.extent(d)[1]) ?","            period.next(d, period.val(d)+1) :","            period.start(d);*/","};","","","","later.date.prevRollover = function(d, val, constraint, period) {","  return val &gt;= constraint.val(d) ?","            period.start(period.prev(d, period.val(d)-1)) :","            period.start(d);","","/*  return (val &gt;= constraint.val(d)) || !val ?","            period.start(period.prev(d, period.val(d)-1)) :","            period.start(d);*/","};","","","","later.date.daysInMonth = [0, 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];"];
_$jscoverage['date/date.js'][1]++;
later.date = {};
_$jscoverage['date/date.js'][3]++;
later.date.UTC = (function () {
  _$jscoverage['date/date.js'][5]++;
  later.date.build = (function (Y, M, D, h, m, s) {
  _$jscoverage['date/date.js'][6]++;
  return new Date(Date.UTC(Y, M, D, h, m, s));
});
  _$jscoverage['date/date.js'][9]++;
  later.date.isUTC = true;
  _$jscoverage['date/date.js'][10]++;
  later.date.getYear = Date.prototype.getUTCFullYear;
  _$jscoverage['date/date.js'][11]++;
  later.date.getMonth = Date.prototype.getUTCMonth;
  _$jscoverage['date/date.js'][12]++;
  later.date.getDate = Date.prototype.getUTCDate;
  _$jscoverage['date/date.js'][13]++;
  later.date.getDay = Date.prototype.getUTCDay;
  _$jscoverage['date/date.js'][14]++;
  later.date.getHour = Date.prototype.getUTCHours;
  _$jscoverage['date/date.js'][15]++;
  later.date.getMin = Date.prototype.getUTCMinutes;
  _$jscoverage['date/date.js'][16]++;
  later.date.getSec = Date.prototype.getUTCSeconds;
});
_$jscoverage['date/date.js'][19]++;
later.date.localTime = (function () {
  _$jscoverage['date/date.js'][21]++;
  later.date.build = (function (Y, M, D, h, m, s) {
  _$jscoverage['date/date.js'][22]++;
  return new Date(Y, M, D, h, m, s);
});
  _$jscoverage['date/date.js'][25]++;
  later.date.isUTC = false;
  _$jscoverage['date/date.js'][26]++;
  later.date.getYear = Date.prototype.getFullYear;
  _$jscoverage['date/date.js'][27]++;
  later.date.getMonth = Date.prototype.getMonth;
  _$jscoverage['date/date.js'][28]++;
  later.date.getDate = Date.prototype.getDate;
  _$jscoverage['date/date.js'][29]++;
  later.date.getDay = Date.prototype.getDay;
  _$jscoverage['date/date.js'][30]++;
  later.date.getHour = Date.prototype.getHours;
  _$jscoverage['date/date.js'][31]++;
  later.date.getMin = Date.prototype.getMinutes;
  _$jscoverage['date/date.js'][32]++;
  later.date.getSec = Date.prototype.getSeconds;
});
_$jscoverage['date/date.js'][36]++;
later.date.UTC();
_$jscoverage['date/date.js'][38]++;
later.date.nextRollover = (function (d, val, constraint, period) {
  _$jscoverage['date/date.js'][39]++;
  return (((val <= constraint.val(d)) || (val > constraint.extent(d)[1]))? period.next(d, (period.val(d) + 1)): period.start(d));
});
_$jscoverage['date/date.js'][53]++;
later.date.prevRollover = (function (d, val, constraint, period) {
  _$jscoverage['date/date.js'][54]++;
  return ((val >= constraint.val(d))? period.start(period.prev(d, (period.val(d) - 1))): period.start(d));
});
_$jscoverage['date/date.js'][65]++;
later.date.daysInMonth = [0, 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];
/* automatically generated by JSCoverage - do not edit */
try {
  if (typeof top === 'object' && top !== null && typeof top.opener === 'object' && top.opener !== null) {
    // this is a browser window that was opened from another window

    if (! top.opener._$jscoverage) {
      top.opener._$jscoverage = {};
    }
  }
}
catch (e) {}

try {
  if (typeof top === 'object' && top !== null) {
    // this is a browser window

    try {
      if (typeof top.opener === 'object' && top.opener !== null && top.opener._$jscoverage) {
        top._$jscoverage = top.opener._$jscoverage;
      }
    }
    catch (e) {}

    if (! top._$jscoverage) {
      top._$jscoverage = {};
    }
  }
}
catch (e) {}

try {
  if (typeof top === 'object' && top !== null && top._$jscoverage) {
    _$jscoverage = top._$jscoverage;
  }
}
catch (e) {}
if (typeof _$jscoverage !== 'object') {
  _$jscoverage = {};
}
if (! _$jscoverage['date/constant.js']) {
  _$jscoverage['date/constant.js'] = [];
  _$jscoverage['date/constant.js'][13] = 0;
  _$jscoverage['date/constant.js'][14] = 0;
  _$jscoverage['date/constant.js'][15] = 0;
  _$jscoverage['date/constant.js'][16] = 0;
  _$jscoverage['date/constant.js'][17] = 0;
}
_$jscoverage['date/constant.js'].source = ["/**","* Date Constants","* (c) 2013 Bill, BunKat LLC.","*","* Useful constants for dealing with time conversions.","*","* Later is freely distributable under the MIT license.","* For all details and documentation:","*     http://github.com/bunkat/later","*/","","// Time to milliseconds conversion","later.SEC = 1000;","later.MIN = later.SEC * 60;","later.HOUR = later.MIN * 60;","later.DAY = later.HOUR * 24;","later.WEEK = later.DAY * 7;"];
_$jscoverage['date/constant.js'][13]++;
later.SEC = 1000;
_$jscoverage['date/constant.js'][14]++;
later.MIN = (later.SEC * 60);
_$jscoverage['date/constant.js'][15]++;
later.HOUR = (later.MIN * 60);
_$jscoverage['date/constant.js'][16]++;
later.DAY = (later.HOUR * 24);
_$jscoverage['date/constant.js'][17]++;
later.WEEK = (later.DAY * 7);
/* automatically generated by JSCoverage - do not edit */
try {
  if (typeof top === 'object' && top !== null && typeof top.opener === 'object' && top.opener !== null) {
    // this is a browser window that was opened from another window

    if (! top.opener._$jscoverage) {
      top.opener._$jscoverage = {};
    }
  }
}
catch (e) {}

try {
  if (typeof top === 'object' && top !== null) {
    // this is a browser window

    try {
      if (typeof top.opener === 'object' && top.opener !== null && top.opener._$jscoverage) {
        top._$jscoverage = top.opener._$jscoverage;
      }
    }
    catch (e) {}

    if (! top._$jscoverage) {
      top._$jscoverage = {};
    }
  }
}
catch (e) {}

try {
  if (typeof top === 'object' && top !== null && top._$jscoverage) {
    _$jscoverage = top._$jscoverage;
  }
}
catch (e) {}
if (typeof _$jscoverage !== 'object') {
  _$jscoverage = {};
}
if (! _$jscoverage['date/next.js']) {
  _$jscoverage['date/next.js'] = [];
  _$jscoverage['date/next.js'][24] = 0;
  _$jscoverage['date/next.js'][26] = 0;
}
_$jscoverage['date/next.js'].source = ["/**","* Next","* (c) 2013 Bill, BunKat LLC.","*","* Creates a new Date object defaulted to the first second after the specified","* values.","*","* Later is freely distributable under the MIT license.","* For all details and documentation:","*     http://github.com/bunkat/later","*/","","/**","* Builds and returns a new Date using the specified values.  Date","* returned is either using Local time or UTC based on isLocal.","*","* @param {Int} Y: Four digit year","* @param {Int} M: Month between 1 and 12, defaults to 1","* @param {Int} D: Date between 1 and 31, defaults to 1","* @param {Int} h: Hour between 0 and 23, defaults to 0","* @param {Int} m: Minute between 0 and 59, defaults to 0","* @param {Int} s: Second between 0 and 59, defaults to 0","*/","later.date.next = function(Y, M, D, h, m, s) {","","  return later.date.build(","    Y,","    M !== undefined ? M-1 : 0,","    D !== undefined ? D : 1,","    h || 0,","    m || 0,","    s || 0);","};"];
_$jscoverage['date/next.js'][24]++;
later.date.next = (function (Y, M, D, h, m, s) {
  _$jscoverage['date/next.js'][26]++;
  return later.date.build(Y, ((M !== undefined)? (M - 1): 0), ((D !== undefined)? D: 1), (h || 0), (m || 0), (s || 0));
});
/* automatically generated by JSCoverage - do not edit */
try {
  if (typeof top === 'object' && top !== null && typeof top.opener === 'object' && top.opener !== null) {
    // this is a browser window that was opened from another window

    if (! top.opener._$jscoverage) {
      top.opener._$jscoverage = {};
    }
  }
}
catch (e) {}

try {
  if (typeof top === 'object' && top !== null) {
    // this is a browser window

    try {
      if (typeof top.opener === 'object' && top.opener !== null && top.opener._$jscoverage) {
        top._$jscoverage = top.opener._$jscoverage;
      }
    }
    catch (e) {}

    if (! top._$jscoverage) {
      top._$jscoverage = {};
    }
  }
}
catch (e) {}

try {
  if (typeof top === 'object' && top !== null && top._$jscoverage) {
    _$jscoverage = top._$jscoverage;
  }
}
catch (e) {}
if (typeof _$jscoverage !== 'object') {
  _$jscoverage = {};
}
if (! _$jscoverage['date/prev.js']) {
  _$jscoverage['date/prev.js'] = [];
  _$jscoverage['date/prev.js'][24] = 0;
  _$jscoverage['date/prev.js'][26] = 0;
  _$jscoverage['date/prev.js'][27] = 0;
  _$jscoverage['date/prev.js'][28] = 0;
  _$jscoverage['date/prev.js'][29] = 0;
  _$jscoverage['date/prev.js'][30] = 0;
  _$jscoverage['date/prev.js'][31] = 0;
  _$jscoverage['date/prev.js'][33] = 0;
}
_$jscoverage['date/prev.js'].source = ["/**","* Prev","* (c) 2013 Bill, BunKat LLC.","*","* Creates a new Date object defaulted to the last second after the specified","* values.","*","* Later is freely distributable under the MIT license.","* For all details and documentation:","*     http://github.com/bunkat/later","*/","","/**","* Builds and returns a new Date using the specified values.  Date","* returned is either using Local time or UTC based on isLocal.","*","* @param {Int} Y: Four digit year","* @param {Int} M: Month between 0 and 11, defaults to 11","* @param {Int} D: Date between 1 and 31, defaults to last day of month","* @param {Int} h: Hour between 0 and 23, defaults to 23","* @param {Int} m: Minute between 0 and 59, defaults to 59","* @param {Int} s: Second between 0 and 59, defaults to 59","*/","later.date.prev = function(Y, M, D, h, m, s) {","","  var len = arguments.length;","  M = len &lt; 2 ? 11 : M-1;","  D = len &lt; 3 ? later.D.extent(later.date.next(Y, M+1))[1] : D;","  h = len &lt; 4 ? 23 : h;","  m = len &lt; 5 ? 59 : m;","  s = len &lt; 6 ? 59 : s;","","  return later.date.build(Y, M, D, h, m, s);","};"];
_$jscoverage['date/prev.js'][24]++;
later.date.prev = (function (Y, M, D, h, m, s) {
  _$jscoverage['date/prev.js'][26]++;
  var len = arguments.length;
  _$jscoverage['date/prev.js'][27]++;
  M = ((len < 2)? 11: (M - 1));
  _$jscoverage['date/prev.js'][28]++;
  D = ((len < 3)? later.D.extent(later.date.next(Y, (M + 1)))[1]: D);
  _$jscoverage['date/prev.js'][29]++;
  h = ((len < 4)? 23: h);
  _$jscoverage['date/prev.js'][30]++;
  m = ((len < 5)? 59: m);
  _$jscoverage['date/prev.js'][31]++;
  s = ((len < 6)? 59: s);
  _$jscoverage['date/prev.js'][33]++;
  return later.date.build(Y, M, D, h, m, s);
});
/* automatically generated by JSCoverage - do not edit */
try {
  if (typeof top === 'object' && top !== null && typeof top.opener === 'object' && top.opener !== null) {
    // this is a browser window that was opened from another window

    if (! top.opener._$jscoverage) {
      top.opener._$jscoverage = {};
    }
  }
}
catch (e) {}

try {
  if (typeof top === 'object' && top !== null) {
    // this is a browser window

    try {
      if (typeof top.opener === 'object' && top.opener !== null && top.opener._$jscoverage) {
        top._$jscoverage = top.opener._$jscoverage;
      }
    }
    catch (e) {}

    if (! top._$jscoverage) {
      top._$jscoverage = {};
    }
  }
}
catch (e) {}

try {
  if (typeof top === 'object' && top !== null && top._$jscoverage) {
    _$jscoverage = top._$jscoverage;
  }
}
catch (e) {}
if (typeof _$jscoverage !== 'object') {
  _$jscoverage = {};
}
if (! _$jscoverage['parse/parse.js']) {
  _$jscoverage['parse/parse.js'] = [];
  _$jscoverage['parse/parse.js'][1] = 0;
}
_$jscoverage['parse/parse.js'].source = ["later.parse = {};"];
_$jscoverage['parse/parse.js'][1]++;
later.parse = {};
/* automatically generated by JSCoverage - do not edit */
try {
  if (typeof top === 'object' && top !== null && typeof top.opener === 'object' && top.opener !== null) {
    // this is a browser window that was opened from another window

    if (! top.opener._$jscoverage) {
      top.opener._$jscoverage = {};
    }
  }
}
catch (e) {}

try {
  if (typeof top === 'object' && top !== null) {
    // this is a browser window

    try {
      if (typeof top.opener === 'object' && top.opener !== null && top.opener._$jscoverage) {
        top._$jscoverage = top.opener._$jscoverage;
      }
    }
    catch (e) {}

    if (! top._$jscoverage) {
      top._$jscoverage = {};
    }
  }
}
catch (e) {}

try {
  if (typeof top === 'object' && top !== null && top._$jscoverage) {
    _$jscoverage = top._$jscoverage;
  }
}
catch (e) {}
if (typeof _$jscoverage !== 'object') {
  _$jscoverage = {};
}
if (! _$jscoverage['parse/cron.js']) {
  _$jscoverage['parse/cron.js'] = [];
  _$jscoverage['parse/cron.js'][6] = 0;
  _$jscoverage['parse/cron.js'][9] = 0;
  _$jscoverage['parse/cron.js'][16] = 0;
  _$jscoverage['parse/cron.js'][34] = 0;
  _$jscoverage['parse/cron.js'][35] = 0;
  _$jscoverage['parse/cron.js'][44] = 0;
  _$jscoverage['parse/cron.js'][45] = 0;
  _$jscoverage['parse/cron.js'][47] = 0;
  _$jscoverage['parse/cron.js'][48] = 0;
  _$jscoverage['parse/cron.js'][49] = 0;
  _$jscoverage['parse/cron.js'][53] = 0;
  _$jscoverage['parse/cron.js'][65] = 0;
  _$jscoverage['parse/cron.js'][66] = 0;
  _$jscoverage['parse/cron.js'][68] = 0;
  _$jscoverage['parse/cron.js'][69] = 0;
  _$jscoverage['parse/cron.js'][72] = 0;
  _$jscoverage['parse/cron.js'][73] = 0;
  _$jscoverage['parse/cron.js'][74] = 0;
  _$jscoverage['parse/cron.js'][76] = 0;
  _$jscoverage['parse/cron.js'][88] = 0;
  _$jscoverage['parse/cron.js'][92] = 0;
  _$jscoverage['parse/cron.js'][94] = 0;
  _$jscoverage['parse/cron.js'][95] = 0;
  _$jscoverage['parse/cron.js'][98] = 0;
  _$jscoverage['parse/cron.js'][99] = 0;
  _$jscoverage['parse/cron.js'][102] = 0;
  _$jscoverage['parse/cron.js'][103] = 0;
  _$jscoverage['parse/cron.js'][104] = 0;
  _$jscoverage['parse/cron.js'][107] = 0;
  _$jscoverage['parse/cron.js'][108] = 0;
  _$jscoverage['parse/cron.js'][109] = 0;
  _$jscoverage['parse/cron.js'][110] = 0;
  _$jscoverage['parse/cron.js'][111] = 0;
  _$jscoverage['parse/cron.js'][112] = 0;
  _$jscoverage['parse/cron.js'][117] = 0;
  _$jscoverage['parse/cron.js'][118] = 0;
  _$jscoverage['parse/cron.js'][119] = 0;
  _$jscoverage['parse/cron.js'][120] = 0;
  _$jscoverage['parse/cron.js'][121] = 0;
  _$jscoverage['parse/cron.js'][122] = 0;
  _$jscoverage['parse/cron.js'][124] = 0;
  _$jscoverage['parse/cron.js'][125] = 0;
  _$jscoverage['parse/cron.js'][138] = 0;
  _$jscoverage['parse/cron.js'][140] = 0;
  _$jscoverage['parse/cron.js'][145] = 0;
  _$jscoverage['parse/cron.js'][146] = 0;
  _$jscoverage['parse/cron.js'][147] = 0;
  _$jscoverage['parse/cron.js'][148] = 0;
  _$jscoverage['parse/cron.js'][150] = 0;
  _$jscoverage['parse/cron.js'][163] = 0;
  _$jscoverage['parse/cron.js'][164] = 0;
  _$jscoverage['parse/cron.js'][170] = 0;
  _$jscoverage['parse/cron.js'][171] = 0;
  _$jscoverage['parse/cron.js'][175] = 0;
  _$jscoverage['parse/cron.js'][176] = 0;
  _$jscoverage['parse/cron.js'][179] = 0;
  _$jscoverage['parse/cron.js'][180] = 0;
  _$jscoverage['parse/cron.js'][183] = 0;
  _$jscoverage['parse/cron.js'][184] = 0;
  _$jscoverage['parse/cron.js'][187] = 0;
  _$jscoverage['parse/cron.js'][188] = 0;
  _$jscoverage['parse/cron.js'][189] = 0;
  _$jscoverage['parse/cron.js'][193] = 0;
  _$jscoverage['parse/cron.js'][202] = 0;
  _$jscoverage['parse/cron.js'][203] = 0;
  _$jscoverage['parse/cron.js'][207] = 0;
  _$jscoverage['parse/cron.js'][208] = 0;
  _$jscoverage['parse/cron.js'][217] = 0;
  _$jscoverage['parse/cron.js'][218] = 0;
  _$jscoverage['parse/cron.js'][222] = 0;
  _$jscoverage['parse/cron.js'][223] = 0;
  _$jscoverage['parse/cron.js'][224] = 0;
  _$jscoverage['parse/cron.js'][225] = 0;
  _$jscoverage['parse/cron.js'][229] = 0;
  _$jscoverage['parse/cron.js'][230] = 0;
  _$jscoverage['parse/cron.js'][231] = 0;
  _$jscoverage['parse/cron.js'][232] = 0;
  _$jscoverage['parse/cron.js'][237] = 0;
  _$jscoverage['parse/cron.js'][240] = 0;
  _$jscoverage['parse/cron.js'][253] = 0;
  _$jscoverage['parse/cron.js'][254] = 0;
}
_$jscoverage['parse/cron.js'].source = ["/**","* Parses a cron expression and produces a schedule that is compatible","* with Later.js.  See http://en.wikipedia.org/wiki/Cron for details of","* the cron format.","*/","later.parse.cron = function () {","","  // Constant array to convert valid names to values","  var NAMES = {","    JAN: 1, FEB: 2, MAR: 3, APR: 4, MAY: 5, JUN: 6, JUL: 7, AUG: 8,","    SEP: 9, OCT: 10, NOV: 11, DEC: 12,","    SUN: 1, MON: 2, TUE: 3, WED: 4, THU: 5, FRI: 6, SAT: 7","  };","","  // Contains the index, min, and max for each of the constraints","  var FIELDS = {","    s: [0, 0, 59],      // seconds","    m: [1, 0, 59],      // minutes","    h: [2, 0, 23],      // hours","    D: [3, 1, 31],      // day of month","    M: [4, 1, 12],      // month","    Y: [6, 1970, 2099], // year","    d: [5, 1, 7, 1]     // day of week","  };","","  /**","  * Returns the value + offset if value is a number, otherwise it","  * attempts to look up the value in the NAMES table and returns","  * that result instead.","  *","  * @param {Int,String} value: The value that should be parsed","  * @param {Int} offset: Any offset that must be added to the value","  */","  function getValue(value, offset) {","    return isNaN(value) ? NAMES[value] || null : +value + (offset || 0);","  }","","  /**","  * Returns a deep clone of a schedule skipping any day of week","  * constraints.","  *","  * @param {Sched} sched: The schedule that will be cloned","  */","  function cloneSchedule(sched) {","    var clone = {}, field;","","    for(field in sched) {","      if (field !== 'dc' &amp;&amp; field !== 'd') {","        clone[field] = sched[field].slice(0);","      }","    }","","    return clone;","  }","","  /**","  * Adds values to the specified constraint in the current schedule.","  *","  * @param {Sched} sched: The schedule to add the constraint to","  * @param {String} name: Name of constraint to add","  * @param {Int} min: Minimum value for this constraint","  * @param {Int} max: Maximum value for this constraint","  * @param {Int} inc: The increment to use between min and max","  */","  function add(sched, name, min, max, inc) {","    var i = min;","","    if (!sched[name]) {","      sched[name] = [];","    }","","    while (i &lt;= max) {","      if (sched[name].indexOf(i) &lt; 0) {","        sched[name].push(i);","      }","      i += inc || 1;","    }","  }","","  /**","  * Adds a hash item (of the form x#y or xL) to the schedule.","  *","  * @param {Schedule} schedules: The current schedule array to add to","  * @param {Schedule} curSched: The current schedule to add to","  * @param {Int} value: The value to add (x of x#y or xL)","  * @param {Int} hash: The hash value to add (y of x#y)","  */","  function addHash(schedules, curSched, value, hash) {","    // if there are any existing day of week constraints that","    // aren't equal to the one we're adding, create a new","    // composite schedule","    if ((curSched.d &amp;&amp; !curSched.dc) ||","        (curSched.dc &amp;&amp; curSched.dc.indexOf(hash) &lt; 0)) {","      schedules.push(cloneSchedule(curSched));","      curSched = schedules[schedules.length-1];","    }","","    add(curSched, 'd', value, value);","    add(curSched, 'dc', hash, hash);","  }","","  function addWeekday(s, curSched, value) {","     var except1 = {}, except2 = {};","     if (value=== 1) {","      // cron doesn't pass month boundaries, so if 1st is a","      // weekend then we need to use 2nd or 3rd instead","      add(curSched, 'D', 1, 3);","      add(curSched, 'd', NAMES.MON, NAMES.FRI);","      add(except1, 'D', 2, 2);","      add(except1, 'd', NAMES.TUE, NAMES.FRI);","      add(except2, 'D', 3, 3);","      add(except2, 'd', NAMES.TUE, NAMES.FRI);","    } else {","      // normally you want the closest day, so if v is a","      // Saturday, use the previous Friday.  If it's a","      // sunday, use the following Monday.","      add(curSched, 'D', value-1, value+1);","      add(curSched, 'd', NAMES.MON, NAMES.FRI);","      add(except1, 'D', value-1, value-1);","      add(except1, 'd', NAMES.MON, NAMES.THU);","      add(except2, 'D', value+1, value+1);","      add(except2, 'd', NAMES.TUE, NAMES.FRI);","    }","    s.exceptions.push(except1);","    s.exceptions.push(except2);","  }","","  /**","  * Adds a range item (of the form x-y/z) to the schedule.","  *","  * @param {String} item: The cron expression item to add","  * @param {Schedule} curSched: The current schedule to add to","  * @param {String} name: The name to use for this constraint","  * @param {Int} min: The min value for the constraint","  * @param {Int} max: The max value for the constraint","  * @param {Int} offset: The offset to apply to the cron value","  */","  function addRange(item, curSched, name, min, max, offset) {","    // parse range/x","    var incSplit = item.split('/'),","        inc = +incSplit[1],","        range = incSplit[0];","","    // parse x-y or * or 0","    if (range !== '*' &amp;&amp; range !== '0') {","      var rangeSplit = range.split('-');","      min = getValue(rangeSplit[0], offset);","      max = getValue(rangeSplit[1], offset);","    }","    add(curSched, name, min, max, inc);","  }","","  /**","  * Parses a particular item within a cron expression.","  *","  * @param {String} item: The cron expression item to parse","  * @param {Schedule} s: The existing set of schedules","  * @param {String} name: The name to use for this constraint","  * @param {Int} min: The min value for the constraint","  * @param {Int} max: The max value for the constraint","  * @param {Int} offset: The offset to apply to the cron value","  */","  function parse(item, s, name, min, max, offset) {","    var value,","        split,","        schedules = s.schedules,","        curSched = schedules[schedules.length-1];","","    // L just means min - 1 (this also makes it work for any field)","    if (item === 'L') {","      item = min - 1;","    }","","    // parse x","    if ((value = getValue(item, offset)) !== null) {","      add(curSched, name, value, value);","    }","    // parse xW","    else if ((value = getValue(item.replace('W', ''), offset)) !== null) {","      addWeekday(s, curSched, value);","    }","    // parse xL","    else if ((value = getValue(item.replace('L', ''), offset)) !== null) {","      addHash(schedules, curSched, value, min-1);","    }","    // parse x#y","    else if ((split = item.split('#')).length === 2) {","      value = getValue(split[0], offset);","      addHash(schedules, curSched, value, getValue(split[1]));","    }","    // parse x-y or x-y/z or */z or 0/z","    else {","      addRange(item, curSched, name, min, max, offset);","    }","  }","","  /**","  * Returns true if the item is either of the form x#y or xL.","  *","  * @param {String} item: The expression item to check","  */","  function isHash(item) {","    return item.indexOf('#') &gt; -1 || item.indexOf('L') &gt; 0;","  }","","","  function itemSorter(a,b) {","    return isHash(a) &amp;&amp; !isHash(b) ? 1 : 0;","  }","","  /**","  * Parses each of the fields in a cron expression.  The expression must","  * include the seconds field, the year field is optional.","  *","  * @param {String} expr: The cron expression to parse","  */","  function parseExpr(expr) {","    var schedule = {schedules: [{}], exceptions: []},","        components = expr.split(' '),","        field, f, component, items;","","    for(field in FIELDS) {","      f = FIELDS[field];","      component = components[f[0]];","      if (component &amp;&amp; component !== '*' &amp;&amp; component !== '?') {","        // need to sort so that any #'s come last, otherwise","        // schedule clones to handle # won't contain all of the","        // other constraints","        items = component.split(',').sort(itemSorter);","        var i, length = items.length;","        for (i = 0; i &lt; length; i++) {","          parse(items[i], schedule, field, f[1], f[2], f[3]);","        }","      }","    }","","    return schedule;","  }","","  return {","","    /**","    * Parses a valid cron expression and produces a valid schedule that","    * can then be used with Later.","    *","    * CronParser().parse('* 5 * * * * *', true);","    *","    * @param {String} expr: The cron expression to parse","    * @param {Bool} hasSeconds: True if the expression uses a seconds field","    * @api public","    */","    parse: function (expr, hasSeconds) {","      var e = expr.toUpperCase();","      return parseExpr(hasSeconds ? e : '0 ' + e);","    }","","  };","};"];
_$jscoverage['parse/cron.js'][6]++;
later.parse.cron = (function () {
  _$jscoverage['parse/cron.js'][9]++;
  var NAMES = {JAN: 1, FEB: 2, MAR: 3, APR: 4, MAY: 5, JUN: 6, JUL: 7, AUG: 8, SEP: 9, OCT: 10, NOV: 11, DEC: 12, SUN: 1, MON: 2, TUE: 3, WED: 4, THU: 5, FRI: 6, SAT: 7};
  _$jscoverage['parse/cron.js'][16]++;
  var FIELDS = {s: [0, 0, 59], m: [1, 0, 59], h: [2, 0, 23], D: [3, 1, 31], M: [4, 1, 12], Y: [6, 1970, 2099], d: [5, 1, 7, 1]};
  _$jscoverage['parse/cron.js'][34]++;
  function getValue(value, offset) {
    _$jscoverage['parse/cron.js'][35]++;
    return (isNaN(value)? (NAMES[value] || null): ((+ value) + (offset || 0)));
}
  _$jscoverage['parse/cron.js'][44]++;
  function cloneSchedule(sched) {
    _$jscoverage['parse/cron.js'][45]++;
    var clone = {}, field;
    _$jscoverage['parse/cron.js'][47]++;
    for (field in sched) {
      _$jscoverage['parse/cron.js'][48]++;
      if (((field !== "dc") && (field !== "d"))) {
        _$jscoverage['parse/cron.js'][49]++;
        clone[field] = sched[field].slice(0);
      }
}
    _$jscoverage['parse/cron.js'][53]++;
    return clone;
}
  _$jscoverage['parse/cron.js'][65]++;
  function add(sched, name, min, max, inc) {
    _$jscoverage['parse/cron.js'][66]++;
    var i = min;
    _$jscoverage['parse/cron.js'][68]++;
    if ((! sched[name])) {
      _$jscoverage['parse/cron.js'][69]++;
      sched[name] = [];
    }
    _$jscoverage['parse/cron.js'][72]++;
    while ((i <= max)) {
      _$jscoverage['parse/cron.js'][73]++;
      if ((sched[name].indexOf(i) < 0)) {
        _$jscoverage['parse/cron.js'][74]++;
        sched[name].push(i);
      }
      _$jscoverage['parse/cron.js'][76]++;
      i += (inc || 1);
}
}
  _$jscoverage['parse/cron.js'][88]++;
  function addHash(schedules, curSched, value, hash) {
    _$jscoverage['parse/cron.js'][92]++;
    if (((curSched.d && (! curSched.dc)) || (curSched.dc && (curSched.dc.indexOf(hash) < 0)))) {
      _$jscoverage['parse/cron.js'][94]++;
      schedules.push(cloneSchedule(curSched));
      _$jscoverage['parse/cron.js'][95]++;
      curSched = schedules[(schedules.length - 1)];
    }
    _$jscoverage['parse/cron.js'][98]++;
    add(curSched, "d", value, value);
    _$jscoverage['parse/cron.js'][99]++;
    add(curSched, "dc", hash, hash);
}
  _$jscoverage['parse/cron.js'][102]++;
  function addWeekday(s, curSched, value) {
    _$jscoverage['parse/cron.js'][103]++;
    var except1 = {}, except2 = {};
    _$jscoverage['parse/cron.js'][104]++;
    if ((value === 1)) {
      _$jscoverage['parse/cron.js'][107]++;
      add(curSched, "D", 1, 3);
      _$jscoverage['parse/cron.js'][108]++;
      add(curSched, "d", NAMES.MON, NAMES.FRI);
      _$jscoverage['parse/cron.js'][109]++;
      add(except1, "D", 2, 2);
      _$jscoverage['parse/cron.js'][110]++;
      add(except1, "d", NAMES.TUE, NAMES.FRI);
      _$jscoverage['parse/cron.js'][111]++;
      add(except2, "D", 3, 3);
      _$jscoverage['parse/cron.js'][112]++;
      add(except2, "d", NAMES.TUE, NAMES.FRI);
    }
    else {
      _$jscoverage['parse/cron.js'][117]++;
      add(curSched, "D", (value - 1), (value + 1));
      _$jscoverage['parse/cron.js'][118]++;
      add(curSched, "d", NAMES.MON, NAMES.FRI);
      _$jscoverage['parse/cron.js'][119]++;
      add(except1, "D", (value - 1), (value - 1));
      _$jscoverage['parse/cron.js'][120]++;
      add(except1, "d", NAMES.MON, NAMES.THU);
      _$jscoverage['parse/cron.js'][121]++;
      add(except2, "D", (value + 1), (value + 1));
      _$jscoverage['parse/cron.js'][122]++;
      add(except2, "d", NAMES.TUE, NAMES.FRI);
    }
    _$jscoverage['parse/cron.js'][124]++;
    s.exceptions.push(except1);
    _$jscoverage['parse/cron.js'][125]++;
    s.exceptions.push(except2);
}
  _$jscoverage['parse/cron.js'][138]++;
  function addRange(item, curSched, name, min, max, offset) {
    _$jscoverage['parse/cron.js'][140]++;
    var incSplit = item.split("/"), inc = (+ incSplit[1]), range = incSplit[0];
    _$jscoverage['parse/cron.js'][145]++;
    if (((range !== "*") && (range !== "0"))) {
      _$jscoverage['parse/cron.js'][146]++;
      var rangeSplit = range.split("-");
      _$jscoverage['parse/cron.js'][147]++;
      min = getValue(rangeSplit[0], offset);
      _$jscoverage['parse/cron.js'][148]++;
      max = getValue(rangeSplit[1], offset);
    }
    _$jscoverage['parse/cron.js'][150]++;
    add(curSched, name, min, max, inc);
}
  _$jscoverage['parse/cron.js'][163]++;
  function parse(item, s, name, min, max, offset) {
    _$jscoverage['parse/cron.js'][164]++;
    var value, split, schedules = s.schedules, curSched = schedules[(schedules.length - 1)];
    _$jscoverage['parse/cron.js'][170]++;
    if ((item === "L")) {
      _$jscoverage['parse/cron.js'][171]++;
      item = (min - 1);
    }
    _$jscoverage['parse/cron.js'][175]++;
    if (((value = getValue(item, offset)) !== null)) {
      _$jscoverage['parse/cron.js'][176]++;
      add(curSched, name, value, value);
    }
    else {
      _$jscoverage['parse/cron.js'][179]++;
      if (((value = getValue(item.replace("W", ""), offset)) !== null)) {
        _$jscoverage['parse/cron.js'][180]++;
        addWeekday(s, curSched, value);
      }
      else {
        _$jscoverage['parse/cron.js'][183]++;
        if (((value = getValue(item.replace("L", ""), offset)) !== null)) {
          _$jscoverage['parse/cron.js'][184]++;
          addHash(schedules, curSched, value, (min - 1));
        }
        else {
          _$jscoverage['parse/cron.js'][187]++;
          if (((split = item.split("#")).length === 2)) {
            _$jscoverage['parse/cron.js'][188]++;
            value = getValue(split[0], offset);
            _$jscoverage['parse/cron.js'][189]++;
            addHash(schedules, curSched, value, getValue(split[1]));
          }
          else {
            _$jscoverage['parse/cron.js'][193]++;
            addRange(item, curSched, name, min, max, offset);
          }
        }
      }
    }
}
  _$jscoverage['parse/cron.js'][202]++;
  function isHash(item) {
    _$jscoverage['parse/cron.js'][203]++;
    return ((item.indexOf("#") > -1) || (item.indexOf("L") > 0));
}
  _$jscoverage['parse/cron.js'][207]++;
  function itemSorter(a, b) {
    _$jscoverage['parse/cron.js'][208]++;
    return ((isHash(a) && (! isHash(b)))? 1: 0);
}
  _$jscoverage['parse/cron.js'][217]++;
  function parseExpr(expr) {
    _$jscoverage['parse/cron.js'][218]++;
    var schedule = {schedules: [{}], exceptions: []}, components = expr.split(" "), field, f, component, items;
    _$jscoverage['parse/cron.js'][222]++;
    for (field in FIELDS) {
      _$jscoverage['parse/cron.js'][223]++;
      f = FIELDS[field];
      _$jscoverage['parse/cron.js'][224]++;
      component = components[f[0]];
      _$jscoverage['parse/cron.js'][225]++;
      if ((component && (component !== "*") && (component !== "?"))) {
        _$jscoverage['parse/cron.js'][229]++;
        items = component.split(",").sort(itemSorter);
        _$jscoverage['parse/cron.js'][230]++;
        var i, length = items.length;
        _$jscoverage['parse/cron.js'][231]++;
        for (i = 0; (i < length); (i++)) {
          _$jscoverage['parse/cron.js'][232]++;
          parse(items[i], schedule, field, f[1], f[2], f[3]);
}
      }
}
    _$jscoverage['parse/cron.js'][237]++;
    return schedule;
}
  _$jscoverage['parse/cron.js'][240]++;
  return ({parse: (function (expr, hasSeconds) {
  _$jscoverage['parse/cron.js'][253]++;
  var e = expr.toUpperCase();
  _$jscoverage['parse/cron.js'][254]++;
  return parseExpr((hasSeconds? e: ("0 " + e)));
})});
});
/* automatically generated by JSCoverage - do not edit */
try {
  if (typeof top === 'object' && top !== null && typeof top.opener === 'object' && top.opener !== null) {
    // this is a browser window that was opened from another window

    if (! top.opener._$jscoverage) {
      top.opener._$jscoverage = {};
    }
  }
}
catch (e) {}

try {
  if (typeof top === 'object' && top !== null) {
    // this is a browser window

    try {
      if (typeof top.opener === 'object' && top.opener !== null && top.opener._$jscoverage) {
        top._$jscoverage = top.opener._$jscoverage;
      }
    }
    catch (e) {}

    if (! top._$jscoverage) {
      top._$jscoverage = {};
    }
  }
}
catch (e) {}

try {
  if (typeof top === 'object' && top !== null && top._$jscoverage) {
    _$jscoverage = top._$jscoverage;
  }
}
catch (e) {}
if (typeof _$jscoverage !== 'object') {
  _$jscoverage = {};
}
if (! _$jscoverage['parse/recur.js']) {
  _$jscoverage['parse/recur.js'] = [];
  _$jscoverage['parse/recur.js'][13] = 0;
  _$jscoverage['parse/recur.js'][15] = 0;
  _$jscoverage['parse/recur.js'][29] = 0;
  _$jscoverage['parse/recur.js'][30] = 0;
  _$jscoverage['parse/recur.js'][32] = 0;
  _$jscoverage['parse/recur.js'][33] = 0;
  _$jscoverage['parse/recur.js'][34] = 0;
  _$jscoverage['parse/recur.js'][37] = 0;
  _$jscoverage['parse/recur.js'][38] = 0;
  _$jscoverage['parse/recur.js'][41] = 0;
  _$jscoverage['parse/recur.js'][43] = 0;
  _$jscoverage['parse/recur.js'][44] = 0;
  _$jscoverage['parse/recur.js'][45] = 0;
  _$jscoverage['parse/recur.js'][46] = 0;
  _$jscoverage['parse/recur.js'][50] = 0;
  _$jscoverage['parse/recur.js'][53] = 0;
  _$jscoverage['parse/recur.js'][54] = 0;
  _$jscoverage['parse/recur.js'][55] = 0;
  _$jscoverage['parse/recur.js'][56] = 0;
  _$jscoverage['parse/recur.js'][57] = 0;
  _$jscoverage['parse/recur.js'][62] = 0;
  _$jscoverage['parse/recur.js'][65] = 0;
  _$jscoverage['parse/recur.js'][94] = 0;
  _$jscoverage['parse/recur.js'][95] = 0;
  _$jscoverage['parse/recur.js'][110] = 0;
  _$jscoverage['parse/recur.js'][111] = 0;
  _$jscoverage['parse/recur.js'][126] = 0;
  _$jscoverage['parse/recur.js'][127] = 0;
  _$jscoverage['parse/recur.js'][128] = 0;
  _$jscoverage['parse/recur.js'][142] = 0;
  _$jscoverage['parse/recur.js'][143] = 0;
  _$jscoverage['parse/recur.js'][156] = 0;
  _$jscoverage['parse/recur.js'][157] = 0;
  _$jscoverage['parse/recur.js'][171] = 0;
  _$jscoverage['parse/recur.js'][172] = 0;
  _$jscoverage['parse/recur.js'][173] = 0;
  _$jscoverage['parse/recur.js'][174] = 0;
  _$jscoverage['parse/recur.js'][175] = 0;
  _$jscoverage['parse/recur.js'][179] = 0;
  _$jscoverage['parse/recur.js'][180] = 0;
  _$jscoverage['parse/recur.js'][194] = 0;
  _$jscoverage['parse/recur.js'][195] = 0;
  _$jscoverage['parse/recur.js'][196] = 0;
  _$jscoverage['parse/recur.js'][197] = 0;
  _$jscoverage['parse/recur.js'][198] = 0;
  _$jscoverage['parse/recur.js'][202] = 0;
  _$jscoverage['parse/recur.js'][203] = 0;
  _$jscoverage['parse/recur.js'][217] = 0;
  _$jscoverage['parse/recur.js'][218] = 0;
  _$jscoverage['parse/recur.js'][219] = 0;
  _$jscoverage['parse/recur.js'][220] = 0;
  _$jscoverage['parse/recur.js'][221] = 0;
  _$jscoverage['parse/recur.js'][225] = 0;
  _$jscoverage['parse/recur.js'][226] = 0;
  _$jscoverage['parse/recur.js'][238] = 0;
  _$jscoverage['parse/recur.js'][239] = 0;
  _$jscoverage['parse/recur.js'][251] = 0;
  _$jscoverage['parse/recur.js'][252] = 0;
  _$jscoverage['parse/recur.js'][264] = 0;
  _$jscoverage['parse/recur.js'][265] = 0;
  _$jscoverage['parse/recur.js'][277] = 0;
  _$jscoverage['parse/recur.js'][278] = 0;
  _$jscoverage['parse/recur.js'][297] = 0;
  _$jscoverage['parse/recur.js'][298] = 0;
  _$jscoverage['parse/recur.js'][307] = 0;
  _$jscoverage['parse/recur.js'][308] = 0;
  _$jscoverage['parse/recur.js'][317] = 0;
  _$jscoverage['parse/recur.js'][318] = 0;
  _$jscoverage['parse/recur.js'][338] = 0;
  _$jscoverage['parse/recur.js'][339] = 0;
  _$jscoverage['parse/recur.js'][351] = 0;
  _$jscoverage['parse/recur.js'][352] = 0;
  _$jscoverage['parse/recur.js'][371] = 0;
  _$jscoverage['parse/recur.js'][372] = 0;
  _$jscoverage['parse/recur.js'][385] = 0;
  _$jscoverage['parse/recur.js'][386] = 0;
  _$jscoverage['parse/recur.js'][410] = 0;
  _$jscoverage['parse/recur.js'][411] = 0;
  _$jscoverage['parse/recur.js'][423] = 0;
  _$jscoverage['parse/recur.js'][424] = 0;
  _$jscoverage['parse/recur.js'][438] = 0;
  _$jscoverage['parse/recur.js'][456] = 0;
  _$jscoverage['parse/recur.js'][457] = 0;
  _$jscoverage['parse/recur.js'][458] = 0;
  _$jscoverage['parse/recur.js'][459] = 0;
  _$jscoverage['parse/recur.js'][475] = 0;
  _$jscoverage['parse/recur.js'][476] = 0;
  _$jscoverage['parse/recur.js'][493] = 0;
  _$jscoverage['parse/recur.js'][494] = 0;
  _$jscoverage['parse/recur.js'][495] = 0;
}
_$jscoverage['parse/recur.js'].source = ["/**","* Simple API for generating valid schedules for Later.js.  All commands","* are chainable.","*","* Example:","*","* Every 5 minutes between minutes 15 and 45 of each hour and also","* at 9:00 am every day, except in the months of January and February","*","* recur().every(5).minute().between(15, 45).and().at('09:00:00')","*    .except().on(0, 1).month();","*/","later.parse.recur = function () {","","  var schedules = [],","      exceptions = [],","      cur,","      curArr = schedules,","      curName,","      values, every, after, applyMin, applyMax, i, last;","","  /**","  * Adds values to the specified constraint in the current schedule.","  *","  * @param {String} name: Name of constraint to add","  * @param {Int} min: Minimum value for this constraint","  * @param {Int} max: Maximum value for this constraint","  */","  function add(name, min, max) {","    name = after ? 'a' + name : name;","","    if (!cur) {","      curArr.push({});","      cur = curArr[0];","    }","","    if (!cur[name]) {","      cur[name] = [];","    }","","    curName = cur[name];","","    if (every) {","      values = [];","      for (i = min; i &lt;= max; i += every) {","        values.push(i);","      }","","      // save off values in case of startingOn or between","      last = {n: name, x: every, c: curName.length, m: max};","    }","","    values = applyMin ? [min] : applyMax ? [max] : values;","    var length = values.length;","    for (i = 0; i &lt; length; i += 1) {","      if (curName.indexOf(values[i]) &lt; 0) {","        curName.push(values[i]);","      }","    }","","    // reset the built up state","    values = every = after = applyMin = applyMax = 0;","  }","","  return {","","    /**","    * Set of constraints that must be met for an occurrence to be valid.","    *","    * @api public","    */","    schedules: schedules,","","    /**","    * Set of exceptions that must not be met for an occurrence to be","    * valid.","    *","    * @api public","    */","    exceptions: exceptions,","","    /**","    * Specifies the specific instances of a time period that are valid.","    * Must be followed by the desired time period (minute(), hour(),","    * etc). For example, to specify a schedule for the 5th and 25th","    * minute of every hour:","    *","    * recur().on(5, 25).minute();","    *","    * @param {Int} args: One or more valid instances","    * @api public","    */","    on: function () {","      values = arguments[0] instanceof Array ? arguments[0] : arguments;","      return this;","    },","","    /**","    * Specifies the recurring interval of a time period that are valid.","    * Must be followed by the desired time period (minute(), hour(),","    * etc). For example, to specify a schedule for every 4 hours in the","    * day:","    *","    * recur().every(4).hour();","    *","    * @param {Int} x: Recurring interval","    * @api public","    */","    every: function (x) {","      every = x;","      return this;","    },","","    /**","    * Specifies the minimum interval between occurrences.","    * Must be followed by the desired time period (minute(), hour(),","    * etc). For example, to specify a schedule that occurs after four hours","    * from the start time:","    *","    * recur().after(4).hour();","    *","    * @param {Int} x: Recurring interval","    * @api public","    */","    after: function (x) {","      after = true;","      values = [x];","      return this;","    },","","    /**","    * Specifies that the first instance of a time period is valid. Must","    * be followed by the desired time period (minute(), hour(), etc).","    * For example, to specify a schedule for the first day of every","    * month:","    *","    * recur().first().dayOfMonth();","    *","    * @api public","    */","    first: function () {","      applyMin = 1;","      return this;","    },","","    /**","    * Specifies that the last instance of a time period is valid. Must","    * be followed by the desired time period (minute(), hour(), etc).","    * For example, to specify a schedule for the last day of every year:","    *","    * recur().last().dayOfYear();","    *","    * @api public","    */","    last: function () {","      applyMax = 1;","      return this;","    },","","    /**","    * Specifies a specific time that is valid. Time must be specified in","    * hh:mm:ss format using 24 hour time. For example, to specify","    * a schedule for 8:30 pm every day:","    *","    * recur().at('20:30:00');","    *","    * @param {String} time: Time in hh:mm:ss 24-hour format","    * @api public","    */","    at: function () {","      values = arguments;","      for (var i = 0, len = values.length; i &lt; len; i++) {","        var split = values[i].split(':');","        if (split.length &lt; 3) {","          values[i] += ':00';","        }","      }","","      add('t');","      return this;","    },","","    /**","    * Specifies a specific time that valid occurrences must occur","    * after. Time must be specified in hh:mm:ss format using 24 hour","    * time. For example, to specify a schedule after 8:30 pm every day:","    *","    * recur().afterTime('20:30:00');","    *","    * @param {String} time: Time in hh:mm:ss 24-hour format","    * @api public","    */","    afterTime: function () {","      values = arguments;","      for (var i = 0, len = values.length; i &lt; len; i++) {","        var split = values[i].split(':');","        if (split.length &lt; 3) {","          values[i] += ':00';","        }","      }","","      add('ta');","      return this;","    },","","    /**","    * Specifies a specific time that valid occurrences must occur","    * before. Time must be specified in hh:mm:ss format using 24 hour","    * time. For example, to specify a schedule before 8:30 pm every day:","    *","    * recur().beforeTime('20:30:00');","    *","    * @param {String} time: Time in hh:mm:ss 24-hour format","    * @api public","    */","    beforeTime: function () {","      values = arguments;","      for (var i = 0, len = values.length; i &lt; len; i++) {","        var split = values[i].split(':');","        if (split.length &lt; 3) {","          values[i] += ':00';","        }","      }","","      add('tb');","      return this;","    },","","    /**","    * Seconds time period, denotes seconds within each minute.","    * Minimum value is 0, maximum value is 59. Specify 59 for last.","    *","    * recur().on(5, 15, 25).second();","    *","    * @api public","    */","    second: function () {","      add('s', 0, 59);","      return this;","    },","","    /**","    * Minutes time period, denotes minutes within each hour.","    * Minimum value is 0, maximum value is 59. Specify 59 for last.","    *","    * recur().on(5, 15, 25).minute();","    *","    * @api public","    */","    minute: function () {","      add('m', 0, 59);","      return this;","    },","","    /**","    * Hours time period, denotes hours within each day.","    * Minimum value is 0, maximum value is 23. Specify 23 for last.","    *","    * recur().on(5, 15, 25).hour();","    *","    * @api public","    */","    hour: function () {","      add('h', 0, 23);","      return this;","    },","","    /**","    * Days of month time period, denotes number of days within a month.","    * Minimum value is 1, maximum value is 31.  Specify 0 for last.","    *","    * recur().every(2).dayOfMonth();","    *","    * @api public","    */","    dayOfMonth: function () {","      add('D', 1, applyMax ? 0 : 31);","      return this;","    },","","    /**","    * Days of week time period, denotes the days within a week.","    * Minimum value is 1, maximum value is 7.  Specify 0 for last.","    * 1 - Sunday","    * 2 - Monday","    * 3 - Tuesday","    * 4 - Wednesday","    * 5 - Thursday","    * 6 - Friday","    * 7 - Saturday","    *","    * recur().on(1).dayOfWeek();","    *","    * @api public","    */","    dayOfWeek: function () {","      add('d', 1, 7);","      return this;","    },","","    /**","    * Short hand for on(1,7).dayOfWeek()","    *","    * @api public","    */","    onWeekend: function() {","      values = [1,7];","      return this.dayOfWeek();","    },","","    /**","    * Short hand for on(2,3,4,5,6).dayOfWeek()","    *","    * @api public","    */","    onWeekday: function() {","      values = [2,3,4,5,6];","      return this.dayOfWeek();","    },","","    /**","    * Days of week count time period, denotes the number of times a","    * particular day has occurred within a month.  Used to specify","    * things like second Tuesday, or third Friday in a month.","    * Minimum value is 1, maximum value is 5.  Specify 0 for last.","    * 1 - First occurrence","    * 2 - Second occurrence","    * 3 - Third occurrence","    * 4 - Fourth occurrence","    * 5 - Fifth occurrence","    * 0 - Last occurrence","    *","    * recur().on(1).dayOfWeek().on(1).dayOfWeekCount();","    *","    * @api public","    */","    dayOfWeekCount: function () {","      add('dc', 1, applyMax ? 0 : 5);","      return this;","    },","","    /**","    * Days of year time period, denotes number of days within a year.","    * Minimum value is 1, maximum value is 366.  Specify 0 for last.","    *","    * recur().every(2).dayOfYear();","    *","    * @api public","    */","    dayOfYear: function () {","      add('dy', 1, applyMax ? 0 : 366);","      return this;","    },","","    /**","    * Weeks of month time period, denotes number of weeks within a","    * month. The first week is the week that includes the 1st of the","    * month. Subsequent weeks start on Sunday.","    * Minimum value is 1, maximum value is 5.  Specify 0 for last.","    * February 2nd,  2012 - Week 1","    * February 5th,  2012 - Week 2","    * February 12th, 2012 - Week 3","    * February 19th, 2012 - Week 4","    * February 26th, 2012 - Week 5 (or 0)","    *","    * recur().on(2).weekOfMonth();","    *","    * @api public","    */","    weekOfMonth: function () {","      add('wm', 1, applyMax ? 0 : 5);","      return this;","    },","","    /**","    * Weeks of year time period, denotes the ISO 8601 week date. For","    * more information see: http://en.wikipedia.org/wiki/ISO_week_date.","    * Minimum value is 1, maximum value is 53.  Specify 0 for last.","    *","    * recur().every(2).weekOfYear();","    *","    * @api public","    */","    weekOfYear: function () {","      add('wy', 1, applyMax ? 0 : 53);","      return this;","    },","","    /**","    * Month time period, denotes the months within a year.","    * Minimum value is 1, maximum value is 12.  Specify 0 for last.","    * 1 - January","    * 2 - February","    * 3 - March","    * 4 - April","    * 5 - May","    * 6 - June","    * 7 - July","    * 8 - August","    * 9 - September","    * 10 - October","    * 11 - November","    * 12 - December","    *","    * recur().on(1).dayOfWeek();","    *","    * @api public","    */","    month: function () {","      add('M', 1, 12);","      return this;","    },","","    /**","    * Year time period, denotes the four digit year.","    * Minimum value is 1970, maximum value is 2450 (arbitrary)","    *","    * recur().on(2011, 2012, 2013).year();","    *","    * @api public","    */","    year: function () {","      add('Y', 1970, 2450);","      return this;","    },","","    /**","    * Modifies a recurring interval (specified using every) to start","    * at a given offset.  To create a schedule for every 5 minutes","    * starting on the 6th minute - making minutes 6, 11, 16, etc valid:","    *","    * recur().every(5).minute().startingOn(6);","    *","    * @param {Int} start: The desired starting offset","    * @api public","    */","    startingOn: function (start) {","      return this.between(start, last.m);","    },","","    /**","    * Modifies a recurring interval (specified using every) to start","    * and stop at specified times.  To create a schedule for every","    * 5 minutes starting on the 6th minute and ending on the 11th","    * minute - making minutes 6 and 11 valid:","    *","    * recur().every(5).minute().between(6, 11);","    *","    * @param {Int} start: The desired starting offset","    * @param {Int} end: The last valid value","    * @api public","    */","    between: function (start, end) {","      // remove the values added as part of specifying the last","      // time period and replace them with the new restricted values","      cur[last.n] = cur[last.n].splice(0, last.c);","      every = last.x;","      add(last.n, start, end);","      return this;","    },","","    /**","    * Creates a composite schedule.  With a composite schedule, a valid","    * occurrence of any of the component schedules is considered a valid","    * value for the composite schedule (e.g. they are OR'ed together).","    * To create a schedule for every 5 minutes on Mondays and every 10","    * minutes on Tuesdays:","    *","    * recur().every(5).minutes().on(1).dayOfWeek().and().every(10)","    *    .minutes().on(2).dayOfWeek();","    *","    * @api public","    */","    and: function () {","      cur = curArr[curArr.push({}) - 1];","      return this;","    },","","    /**","    * Creates exceptions to a schedule. Any valid occurrence of the","    * exception schedule (which may also be composite schedules) is","    * considered a invalid schedule occurrence. Everything that follows","    * except will be treated as an exception schedule.  To create a","    * schedule for 8:00 am every Tuesday except for patch Tuesday","    * (second Tuesday each month):","    *","    * recur().at('08:00:00').on(2).dayOfWeek().except()","    *    .dayOfWeekCount(1);","    *","    * @api public","    */","    except: function () {","      curArr = exceptions;","      cur = null;","      return this;","    }","  };","};"];
_$jscoverage['parse/recur.js'][13]++;
later.parse.recur = (function () {
  _$jscoverage['parse/recur.js'][15]++;
  var schedules = [], exceptions = [], cur, curArr = schedules, curName, values, every, after, applyMin, applyMax, i, last;
  _$jscoverage['parse/recur.js'][29]++;
  function add(name, min, max) {
    _$jscoverage['parse/recur.js'][30]++;
    name = (after? ("a" + name): name);
    _$jscoverage['parse/recur.js'][32]++;
    if ((! cur)) {
      _$jscoverage['parse/recur.js'][33]++;
      curArr.push({});
      _$jscoverage['parse/recur.js'][34]++;
      cur = curArr[0];
    }
    _$jscoverage['parse/recur.js'][37]++;
    if ((! cur[name])) {
      _$jscoverage['parse/recur.js'][38]++;
      cur[name] = [];
    }
    _$jscoverage['parse/recur.js'][41]++;
    curName = cur[name];
    _$jscoverage['parse/recur.js'][43]++;
    if (every) {
      _$jscoverage['parse/recur.js'][44]++;
      values = [];
      _$jscoverage['parse/recur.js'][45]++;
      for (i = min; (i <= max); (i += every)) {
        _$jscoverage['parse/recur.js'][46]++;
        values.push(i);
}
      _$jscoverage['parse/recur.js'][50]++;
      last = {n: name, x: every, c: curName.length, m: max};
    }
    _$jscoverage['parse/recur.js'][53]++;
    values = (applyMin? [min]: (applyMax? [max]: values));
    _$jscoverage['parse/recur.js'][54]++;
    var length = values.length;
    _$jscoverage['parse/recur.js'][55]++;
    for (i = 0; (i < length); (i += 1)) {
      _$jscoverage['parse/recur.js'][56]++;
      if ((curName.indexOf(values[i]) < 0)) {
        _$jscoverage['parse/recur.js'][57]++;
        curName.push(values[i]);
      }
}
    _$jscoverage['parse/recur.js'][62]++;
    values = (every = (after = (applyMin = (applyMax = 0))));
}
  _$jscoverage['parse/recur.js'][65]++;
  return ({schedules: schedules, exceptions: exceptions, on: (function () {
  _$jscoverage['parse/recur.js'][94]++;
  values = ((arguments[0] instanceof Array)? arguments[0]: arguments);
  _$jscoverage['parse/recur.js'][95]++;
  return this;
}), every: (function (x) {
  _$jscoverage['parse/recur.js'][110]++;
  every = x;
  _$jscoverage['parse/recur.js'][111]++;
  return this;
}), after: (function (x) {
  _$jscoverage['parse/recur.js'][126]++;
  after = true;
  _$jscoverage['parse/recur.js'][127]++;
  values = [x];
  _$jscoverage['parse/recur.js'][128]++;
  return this;
}), first: (function () {
  _$jscoverage['parse/recur.js'][142]++;
  applyMin = 1;
  _$jscoverage['parse/recur.js'][143]++;
  return this;
}), last: (function () {
  _$jscoverage['parse/recur.js'][156]++;
  applyMax = 1;
  _$jscoverage['parse/recur.js'][157]++;
  return this;
}), at: (function () {
  _$jscoverage['parse/recur.js'][171]++;
  values = arguments;
  _$jscoverage['parse/recur.js'][172]++;
  for (var i = 0, len = values.length; (i < len); (i++)) {
    _$jscoverage['parse/recur.js'][173]++;
    var split = values[i].split(":");
    _$jscoverage['parse/recur.js'][174]++;
    if ((split.length < 3)) {
      _$jscoverage['parse/recur.js'][175]++;
      values[i] += ":00";
    }
}
  _$jscoverage['parse/recur.js'][179]++;
  add("t");
  _$jscoverage['parse/recur.js'][180]++;
  return this;
}), afterTime: (function () {
  _$jscoverage['parse/recur.js'][194]++;
  values = arguments;
  _$jscoverage['parse/recur.js'][195]++;
  for (var i = 0, len = values.length; (i < len); (i++)) {
    _$jscoverage['parse/recur.js'][196]++;
    var split = values[i].split(":");
    _$jscoverage['parse/recur.js'][197]++;
    if ((split.length < 3)) {
      _$jscoverage['parse/recur.js'][198]++;
      values[i] += ":00";
    }
}
  _$jscoverage['parse/recur.js'][202]++;
  add("ta");
  _$jscoverage['parse/recur.js'][203]++;
  return this;
}), beforeTime: (function () {
  _$jscoverage['parse/recur.js'][217]++;
  values = arguments;
  _$jscoverage['parse/recur.js'][218]++;
  for (var i = 0, len = values.length; (i < len); (i++)) {
    _$jscoverage['parse/recur.js'][219]++;
    var split = values[i].split(":");
    _$jscoverage['parse/recur.js'][220]++;
    if ((split.length < 3)) {
      _$jscoverage['parse/recur.js'][221]++;
      values[i] += ":00";
    }
}
  _$jscoverage['parse/recur.js'][225]++;
  add("tb");
  _$jscoverage['parse/recur.js'][226]++;
  return this;
}), second: (function () {
  _$jscoverage['parse/recur.js'][238]++;
  add("s", 0, 59);
  _$jscoverage['parse/recur.js'][239]++;
  return this;
}), minute: (function () {
  _$jscoverage['parse/recur.js'][251]++;
  add("m", 0, 59);
  _$jscoverage['parse/recur.js'][252]++;
  return this;
}), hour: (function () {
  _$jscoverage['parse/recur.js'][264]++;
  add("h", 0, 23);
  _$jscoverage['parse/recur.js'][265]++;
  return this;
}), dayOfMonth: (function () {
  _$jscoverage['parse/recur.js'][277]++;
  add("D", 1, (applyMax? 0: 31));
  _$jscoverage['parse/recur.js'][278]++;
  return this;
}), dayOfWeek: (function () {
  _$jscoverage['parse/recur.js'][297]++;
  add("d", 1, 7);
  _$jscoverage['parse/recur.js'][298]++;
  return this;
}), onWeekend: (function () {
  _$jscoverage['parse/recur.js'][307]++;
  values = [1, 7];
  _$jscoverage['parse/recur.js'][308]++;
  return this.dayOfWeek();
}), onWeekday: (function () {
  _$jscoverage['parse/recur.js'][317]++;
  values = [2, 3, 4, 5, 6];
  _$jscoverage['parse/recur.js'][318]++;
  return this.dayOfWeek();
}), dayOfWeekCount: (function () {
  _$jscoverage['parse/recur.js'][338]++;
  add("dc", 1, (applyMax? 0: 5));
  _$jscoverage['parse/recur.js'][339]++;
  return this;
}), dayOfYear: (function () {
  _$jscoverage['parse/recur.js'][351]++;
  add("dy", 1, (applyMax? 0: 366));
  _$jscoverage['parse/recur.js'][352]++;
  return this;
}), weekOfMonth: (function () {
  _$jscoverage['parse/recur.js'][371]++;
  add("wm", 1, (applyMax? 0: 5));
  _$jscoverage['parse/recur.js'][372]++;
  return this;
}), weekOfYear: (function () {
  _$jscoverage['parse/recur.js'][385]++;
  add("wy", 1, (applyMax? 0: 53));
  _$jscoverage['parse/recur.js'][386]++;
  return this;
}), month: (function () {
  _$jscoverage['parse/recur.js'][410]++;
  add("M", 1, 12);
  _$jscoverage['parse/recur.js'][411]++;
  return this;
}), year: (function () {
  _$jscoverage['parse/recur.js'][423]++;
  add("Y", 1970, 2450);
  _$jscoverage['parse/recur.js'][424]++;
  return this;
}), startingOn: (function (start) {
  _$jscoverage['parse/recur.js'][438]++;
  return this.between(start, last.m);
}), between: (function (start, end) {
  _$jscoverage['parse/recur.js'][456]++;
  cur[last.n] = cur[last.n].splice(0, last.c);
  _$jscoverage['parse/recur.js'][457]++;
  every = last.x;
  _$jscoverage['parse/recur.js'][458]++;
  add(last.n, start, end);
  _$jscoverage['parse/recur.js'][459]++;
  return this;
}), and: (function () {
  _$jscoverage['parse/recur.js'][475]++;
  cur = curArr[(curArr.push({}) - 1)];
  _$jscoverage['parse/recur.js'][476]++;
  return this;
}), except: (function () {
  _$jscoverage['parse/recur.js'][493]++;
  curArr = exceptions;
  _$jscoverage['parse/recur.js'][494]++;
  cur = null;
  _$jscoverage['parse/recur.js'][495]++;
  return this;
})});
});
/* automatically generated by JSCoverage - do not edit */
try {
  if (typeof top === 'object' && top !== null && typeof top.opener === 'object' && top.opener !== null) {
    // this is a browser window that was opened from another window

    if (! top.opener._$jscoverage) {
      top.opener._$jscoverage = {};
    }
  }
}
catch (e) {}

try {
  if (typeof top === 'object' && top !== null) {
    // this is a browser window

    try {
      if (typeof top.opener === 'object' && top.opener !== null && top.opener._$jscoverage) {
        top._$jscoverage = top.opener._$jscoverage;
      }
    }
    catch (e) {}

    if (! top._$jscoverage) {
      top._$jscoverage = {};
    }
  }
}
catch (e) {}

try {
  if (typeof top === 'object' && top !== null && top._$jscoverage) {
    _$jscoverage = top._$jscoverage;
  }
}
catch (e) {}
if (typeof _$jscoverage !== 'object') {
  _$jscoverage = {};
}
if (! _$jscoverage['parse/text.js']) {
  _$jscoverage['parse/text.js'] = [];
  _$jscoverage['parse/text.js'][12] = 0;
  _$jscoverage['parse/text.js'][14] = 0;
  _$jscoverage['parse/text.js'][20] = 0;
  _$jscoverage['parse/text.js'][58] = 0;
  _$jscoverage['parse/text.js'][72] = 0;
  _$jscoverage['parse/text.js'][73] = 0;
  _$jscoverage['parse/text.js'][82] = 0;
  _$jscoverage['parse/text.js'][83] = 0;
  _$jscoverage['parse/text.js'][87] = 0;
  _$jscoverage['parse/text.js'][90] = 0;
  _$jscoverage['parse/text.js'][91] = 0;
  _$jscoverage['parse/text.js'][92] = 0;
  _$jscoverage['parse/text.js'][93] = 0;
  _$jscoverage['parse/text.js'][94] = 0;
  _$jscoverage['parse/text.js'][96] = 0;
  _$jscoverage['parse/text.js'][97] = 0;
  _$jscoverage['parse/text.js'][98] = 0;
  _$jscoverage['parse/text.js'][99] = 0;
  _$jscoverage['parse/text.js'][100] = 0;
  _$jscoverage['parse/text.js'][101] = 0;
  _$jscoverage['parse/text.js'][102] = 0;
  _$jscoverage['parse/text.js'][107] = 0;
  _$jscoverage['parse/text.js'][108] = 0;
  _$jscoverage['parse/text.js'][112] = 0;
  _$jscoverage['parse/text.js'][120] = 0;
  _$jscoverage['parse/text.js'][121] = 0;
  _$jscoverage['parse/text.js'][122] = 0;
  _$jscoverage['parse/text.js'][123] = 0;
  _$jscoverage['parse/text.js'][132] = 0;
  _$jscoverage['parse/text.js'][133] = 0;
  _$jscoverage['parse/text.js'][137] = 0;
  _$jscoverage['parse/text.js'][138] = 0;
  _$jscoverage['parse/text.js'][141] = 0;
  _$jscoverage['parse/text.js'][150] = 0;
  _$jscoverage['parse/text.js'][151] = 0;
  _$jscoverage['parse/text.js'][152] = 0;
  _$jscoverage['parse/text.js'][153] = 0;
  _$jscoverage['parse/text.js'][155] = 0;
  _$jscoverage['parse/text.js'][163] = 0;
  _$jscoverage['parse/text.js'][164] = 0;
  _$jscoverage['parse/text.js'][166] = 0;
  _$jscoverage['parse/text.js'][167] = 0;
  _$jscoverage['parse/text.js'][169] = 0;
  _$jscoverage['parse/text.js'][170] = 0;
  _$jscoverage['parse/text.js'][173] = 0;
  _$jscoverage['parse/text.js'][174] = 0;
  _$jscoverage['parse/text.js'][175] = 0;
  _$jscoverage['parse/text.js'][177] = 0;
  _$jscoverage['parse/text.js'][178] = 0;
  _$jscoverage['parse/text.js'][179] = 0;
  _$jscoverage['parse/text.js'][180] = 0;
  _$jscoverage['parse/text.js'][182] = 0;
  _$jscoverage['parse/text.js'][183] = 0;
  _$jscoverage['parse/text.js'][184] = 0;
  _$jscoverage['parse/text.js'][185] = 0;
  _$jscoverage['parse/text.js'][186] = 0;
  _$jscoverage['parse/text.js'][197] = 0;
  _$jscoverage['parse/text.js'][198] = 0;
  _$jscoverage['parse/text.js'][199] = 0;
  _$jscoverage['parse/text.js'][201] = 0;
  _$jscoverage['parse/text.js'][202] = 0;
  _$jscoverage['parse/text.js'][205] = 0;
  _$jscoverage['parse/text.js'][208] = 0;
  _$jscoverage['parse/text.js'][219] = 0;
  _$jscoverage['parse/text.js'][220] = 0;
  _$jscoverage['parse/text.js'][221] = 0;
  _$jscoverage['parse/text.js'][222] = 0;
  _$jscoverage['parse/text.js'][224] = 0;
  _$jscoverage['parse/text.js'][225] = 0;
  _$jscoverage['parse/text.js'][227] = 0;
  _$jscoverage['parse/text.js'][232] = 0;
  _$jscoverage['parse/text.js'][234] = 0;
  _$jscoverage['parse/text.js'][235] = 0;
  _$jscoverage['parse/text.js'][237] = 0;
  _$jscoverage['parse/text.js'][238] = 0;
  _$jscoverage['parse/text.js'][239] = 0;
  _$jscoverage['parse/text.js'][241] = 0;
  _$jscoverage['parse/text.js'][242] = 0;
  _$jscoverage['parse/text.js'][244] = 0;
  _$jscoverage['parse/text.js'][245] = 0;
  _$jscoverage['parse/text.js'][247] = 0;
  _$jscoverage['parse/text.js'][248] = 0;
  _$jscoverage['parse/text.js'][250] = 0;
  _$jscoverage['parse/text.js'][251] = 0;
  _$jscoverage['parse/text.js'][253] = 0;
  _$jscoverage['parse/text.js'][254] = 0;
  _$jscoverage['parse/text.js'][255] = 0;
  _$jscoverage['parse/text.js'][257] = 0;
  _$jscoverage['parse/text.js'][259] = 0;
  _$jscoverage['parse/text.js'][260] = 0;
  _$jscoverage['parse/text.js'][262] = 0;
  _$jscoverage['parse/text.js'][263] = 0;
  _$jscoverage['parse/text.js'][265] = 0;
  _$jscoverage['parse/text.js'][269] = 0;
  _$jscoverage['parse/text.js'][278] = 0;
  _$jscoverage['parse/text.js'][279] = 0;
  _$jscoverage['parse/text.js'][284] = 0;
  _$jscoverage['parse/text.js'][286] = 0;
  _$jscoverage['parse/text.js'][287] = 0;
  _$jscoverage['parse/text.js'][289] = 0;
  _$jscoverage['parse/text.js'][290] = 0;
  _$jscoverage['parse/text.js'][292] = 0;
  _$jscoverage['parse/text.js'][293] = 0;
  _$jscoverage['parse/text.js'][295] = 0;
  _$jscoverage['parse/text.js'][296] = 0;
  _$jscoverage['parse/text.js'][298] = 0;
  _$jscoverage['parse/text.js'][299] = 0;
  _$jscoverage['parse/text.js'][301] = 0;
  _$jscoverage['parse/text.js'][302] = 0;
  _$jscoverage['parse/text.js'][304] = 0;
  _$jscoverage['parse/text.js'][305] = 0;
  _$jscoverage['parse/text.js'][307] = 0;
  _$jscoverage['parse/text.js'][308] = 0;
  _$jscoverage['parse/text.js'][310] = 0;
  _$jscoverage['parse/text.js'][311] = 0;
  _$jscoverage['parse/text.js'][313] = 0;
  _$jscoverage['parse/text.js'][314] = 0;
  _$jscoverage['parse/text.js'][316] = 0;
  _$jscoverage['parse/text.js'][317] = 0;
  _$jscoverage['parse/text.js'][319] = 0;
  _$jscoverage['parse/text.js'][322] = 0;
  _$jscoverage['parse/text.js'][331] = 0;
  _$jscoverage['parse/text.js'][332] = 0;
  _$jscoverage['parse/text.js'][333] = 0;
  _$jscoverage['parse/text.js'][334] = 0;
  _$jscoverage['parse/text.js'][336] = 0;
  _$jscoverage['parse/text.js'][344] = 0;
  _$jscoverage['parse/text.js'][345] = 0;
  _$jscoverage['parse/text.js'][346] = 0;
  _$jscoverage['parse/text.js'][347] = 0;
  _$jscoverage['parse/text.js'][350] = 0;
  _$jscoverage['parse/text.js'][352] = 0;
  _$jscoverage['parse/text.js'][360] = 0;
  _$jscoverage['parse/text.js'][361] = 0;
  _$jscoverage['parse/text.js'][371] = 0;
  _$jscoverage['parse/text.js'][372] = 0;
  _$jscoverage['parse/text.js'][374] = 0;
  _$jscoverage['parse/text.js'][376] = 0;
  _$jscoverage['parse/text.js'][380] = 0;
  _$jscoverage['parse/text.js'][381] = 0;
  _$jscoverage['parse/text.js'][384] = 0;
  _$jscoverage['parse/text.js'][385] = 0;
  _$jscoverage['parse/text.js'][389] = 0;
  _$jscoverage['parse/text.js'][390] = 0;
  _$jscoverage['parse/text.js'][393] = 0;
  _$jscoverage['parse/text.js'][396] = 0;
  _$jscoverage['parse/text.js'][406] = 0;
}
_$jscoverage['parse/text.js'].source = ["/**","* Parses an English string expression and produces a schedule that is","* compatible with Later.js.","*","* Examples:","*","* every 5 minutes between the 1st and 30th minute","* at 10:00 am on tues of may in 2012","* on the 15-20th day of march-dec","* every 20 seconds every 5 minutes every 4 hours between the 10th and 20th hour","*/","later.parse.text = function () {","","  var recur = later.parse.recur,","      pos = 0,","      input = '',","      error;","","  // Regex expressions for all of the valid tokens","  var TOKENTYPES = {","        eof: /^$/,","        rank: /^((\\d\\d\\d\\d)|([2-5]?1(st)?|[2-5]?2(nd)?|[2-5]?3(rd)?|(0|[1-5]?[4-9]|[1-5]0|1[1-3])(th)?))\\b/,","        time: /^((([0]?[1-9]|1[0-2]):[0-5]\\d(\\s)?(am|pm))|(([0]?\\d|1\\d|2[0-3]):[0-5]\\d))\\b/,","        dayName: /^((sun|mon|tue(s)?|wed(nes)?|thu(r(s)?)?|fri|sat(ur)?)(day)?)\\b/,","        monthName: /^(jan(uary)?|feb(ruary)?|ma((r(ch)?)?|y)|apr(il)?|ju(ly|ne)|aug(ust)?|oct(ober)?|(sept|nov|dec)(ember)?)\\b/,","        yearIndex: /^(\\d\\d\\d\\d)\\b/,","        every: /^every\\b/,","        after: /^after\\b/,","        second: /^(s|sec(ond)?(s)?)\\b/,","        minute: /^(m|min(ute)?(s)?)\\b/,","        hour: /^(h|hour(s)?)\\b/,","        day: /^(day(s)?( of the month)?)\\b/,","        dayInstance: /^day instance\\b/,","        dayOfWeek: /^day(s)? of the week\\b/,","        dayOfYear: /^day(s)? of the year\\b/,","        weekOfYear: /^week(s)?( of the year)?\\b/,","        weekOfMonth: /^week(s)? of the month\\b/,","        weekday: /^weekday\\b/,","        weekend: /^weekend\\b/,","        month: /^month(s)?\\b/,","        year: /^year(s)?\\b/,","        between: /^between (the)?\\b/,","        start: /^(start(ing)? (at|on( the)?)?)\\b/,","        at: /^(at|@)\\b/,","        and: /^(,|and\\b)/,","        except: /^(except\\b)/,","        also: /(also)\\b/,","        first: /^(first)\\b/,","        last: /^last\\b/,","        \"in\": /^in\\b/,","        of: /^of\\b/,","        onthe: /^on the\\b/,","        on: /^on\\b/,","        through: /(-|^(to|through)\\b)/","      };","","  // Array to convert string names to valid numerical values","  var NAMES = { jan: 1, feb: 2, mar: 3, apr: 4, may: 5, jun: 6, jul: 7,","        aug: 8, sep: 9, oct: 10, nov: 11, dec: 12, sun: 1, mon: 2, tue: 3,","        wed: 4, thu: 5, fri: 6, sat: 7, '1st': 1, fir: 1, '2nd': 2, sec: 2,","        '3rd': 3, thi: 3, '4th': 4, 'for': 4","      };","","  /**","  * Bundles up the results of the peek operation into a token.","  *","  * @param {Int} start: The start position of the token","  * @param {Int} end: The end position of the token","  * @param {String} text: The actual text that was parsed","  * @param {TokenType} type: The TokenType of the token","  */","  function t(start, end, text, type) {","    return {startPos: start, endPos: end, text: text, type: type};","  }","","  /**","  * Peeks forward to see if the next token is the expected token and","  * returns the token if found.  Pos is not moved during a Peek operation.","  *","  * @param {TokenType} exepected: The types of token to scan for","  */","  function peek(expected) {","    var scanTokens = expected instanceof Array ? expected : [expected],","        whiteSpace = /\\s+/,","        token, curInput, m, scanToken, start, len;","","    scanTokens.push(whiteSpace);","","    // loop past any skipped tokens and only look for expected tokens","    start = pos;","    while (!token || token.type === whiteSpace) {","      len = -1;","      curInput = input.substring(start);","      token = t(start, start, input.split(whiteSpace)[0]);","","      var i, length = scanTokens.length;","      for(i = 0; i &lt; length; i++) {","        scanToken = scanTokens[i];","        m = scanToken.exec(curInput);","        if (m &amp;&amp; m.index === 0 &amp;&amp; m[0].length &gt; len) {","          len = m[0].length;","          token = t(start, start + len, curInput.substring(0, len), scanToken);","        }","      }","","      // update the start position if this token should be skipped","      if (token.type === whiteSpace) {","        start = token.endPos;","      }","    }","","    return token;","  }","","  /**","  * Moves pos to the end of the expectedToken if it is found.","  *","  * @param {TokenType} exepectedToken: The types of token to scan for","  */","  function scan(expectedToken) {","    var token = peek(expectedToken);","    pos = token.endPos;","    return token;","  }","","  /**","  * Parses the next 'y-z' expression and returns the resulting valid","  * value array.","  *","  * @param {TokenType} tokenType: The type of range values allowed","  */","  function parseThroughExpr(tokenType) {","    var start = +parseTokenValue(tokenType),","        end = checkAndParse(TOKENTYPES.through) ? +parseTokenValue(tokenType) : start,","        nums = [];","","    for (var i = start; i &lt;= end; i++) {","      nums.push(i);","    }","","    return nums;","  }","","  /**","  * Parses the next 'x,y-z' expression and returns the resulting valid","  * value array.","  *","  * @param {TokenType} tokenType: The type of range values allowed","  */","  function parseRanges(tokenType) {","    var nums = parseThroughExpr(tokenType);","    while (checkAndParse(TOKENTYPES.and)) {","      nums = nums.concat(parseThroughExpr(tokenType));","    }","    return nums;","  }","","  /**","  * Parses the next 'every (weekend|weekday|x) (starting on|between)' expression.","  *","  * @param {Recur} r: The recurrence to add the expression to","  */","  function parseEvery(r) {","    var num, period, start, end;","","    if (checkAndParse(TOKENTYPES.weekend)) {","      r.on(NAMES.sun,NAMES.sat).dayOfWeek();","    }","    else if (checkAndParse(TOKENTYPES.weekday)) {","      r.on(NAMES.mon,NAMES.tue,NAMES.wed,NAMES.thu,NAMES.fri).dayOfWeek();","    }","    else {","      num = parseTokenValue(TOKENTYPES.rank);","      r.every(num);","      period = parseTimePeriod(r);","","      if (checkAndParse(TOKENTYPES.start)) {","        num = parseTokenValue(TOKENTYPES.rank);","        r.startingOn(num);","        parseToken(period.type);","      }","      else if (checkAndParse(TOKENTYPES.between)) {","        start = parseTokenValue(TOKENTYPES.rank);","        if (checkAndParse(TOKENTYPES.and)) {","          end = parseTokenValue(TOKENTYPES.rank);","          r.between(start,end);","        }","      }","    }","  }","","  /**","  * Parses the next 'on the (first|last|x,y-z)' expression.","  *","  * @param {Recur} r: The recurrence to add the expression to","  */","  function parseOnThe(r) {","    if (checkAndParse(TOKENTYPES.first)) {","      r.first();","    }","    else if (checkAndParse(TOKENTYPES.last)) {","      r.last();","    }","    else {","      r.on(parseRanges(TOKENTYPES.rank));","    }","","    parseTimePeriod(r);","  }","","  /**","  * Parses the schedule expression and returns the resulting schedules,","  * and exceptions.  Error will return the position in the string where","  * an error occurred, will be null if no errors were found in the","  * expression.","  *","  * @param {String} str: The schedule expression to parse","  */","  function parseScheduleExpr(str) {","    pos = 0;","    input = str;","    error = -1;","","    var r = recur();","    while (pos &lt; input.length &amp;&amp; error &lt; 0) {","","      var token = parseToken([TOKENTYPES.every, TOKENTYPES.after,","            TOKENTYPES.onthe, TOKENTYPES.on, TOKENTYPES.of, TOKENTYPES[\"in\"],","            TOKENTYPES.at, TOKENTYPES.and, TOKENTYPES.except,","            TOKENTYPES.also]);","","      switch (token.type) {","        case TOKENTYPES.every:","          parseEvery(r);","          break;","        case TOKENTYPES.after:","          r.after(parseTokenValue(TOKENTYPES.rank));","          parseTimePeriod(r);","          break;","        case TOKENTYPES.onthe:","          parseOnThe(r);","          break;","        case TOKENTYPES.on:","          r.on(parseRanges(TOKENTYPES.dayName)).dayOfWeek();","          break;","        case TOKENTYPES.of:","          r.on(parseRanges(TOKENTYPES.monthName)).month();","          break;","        case TOKENTYPES[\"in\"]:","          r.on(parseRanges(TOKENTYPES.yearIndex)).year();","          break;","        case TOKENTYPES.at:","          r.at(parseTokenValue(TOKENTYPES.time));","          while (checkAndParse(TOKENTYPES.and)) {","            r.at(parseTokenValue(TOKENTYPES.time));","          }","          break;","        case TOKENTYPES.also:","          r.and();","          break;","        case TOKENTYPES.except:","          r.except();","          break;","        default:","          error = pos;","      }","    }","","    return {schedules: r.schedules, exceptions: r.exceptions, error: error};","  }","","  /**","  * Parses the next token representing a time period and adds it to","  * the provided recur object.","  *","  * @param {Recur} r: The recurrence to add the time period to","  */","  function parseTimePeriod(r) {","    var timePeriod = parseToken([TOKENTYPES.second, TOKENTYPES.minute,","          TOKENTYPES.hour, TOKENTYPES.dayOfYear, TOKENTYPES.dayOfWeek,","          TOKENTYPES.dayInstance, TOKENTYPES.day, TOKENTYPES.month,","          TOKENTYPES.year, TOKENTYPES.weekOfMonth, TOKENTYPES.weekOfYear]);","","    switch (timePeriod.type) {","      case TOKENTYPES.second:","        r.second();","        break;","      case TOKENTYPES.minute:","        r.minute();","        break;","      case TOKENTYPES.hour:","        r.hour();","        break;","      case TOKENTYPES.dayOfYear:","        r.dayOfYear();","        break;","      case TOKENTYPES.dayOfWeek:","        r.dayOfWeek();","        break;","      case TOKENTYPES.dayInstance:","        r.dayOfWeekCount();","        break;","      case TOKENTYPES.day:","        r.dayOfMonth();","        break;","      case TOKENTYPES.weekOfMonth:","        r.weekOfMonth();","        break;","      case TOKENTYPES.weekOfYear:","        r.weekOfYear();","        break;","      case TOKENTYPES.month:","        r.month();","        break;","      case TOKENTYPES.year:","        r.year();","        break;","      default:","        error = pos;","    }","","    return timePeriod;","  }","","  /**","  * Checks the next token to see if it is of tokenType. Returns true if","  * it is and discards the token.  Returns false otherwise.","  *","  * @param {TokenType} tokenType: The type or types of token to parse","  */","  function checkAndParse(tokenType) {","    var found = (peek(tokenType)).type === tokenType;","    if (found) {","      scan(tokenType);","    }","    return found;","  }","","  /**","  * Parses and returns the next token.","  *","  * @param {TokenType} tokenType: The type or types of token to parse","  */","  function parseToken(tokenType) {","    var t = scan(tokenType);","    if (t.type) {","      t.text = convertString(t.text, tokenType);","    }","    else {","      error = pos;","    }","    return t;","  }","","  /**","  * Returns the text value of the token that was parsed.","  *","  * @param {TokenType} tokenType: The type of token to parse","  */","  function parseTokenValue(tokenType) {","    return (parseToken(tokenType)).text;","  }","","  /**","  * Converts a string value to a numerical value based on the type of","  * token that was parsed.","  *","  * @param {String} str: The schedule string to parse","  * @param {TokenType} tokenType: The type of token to convert","  */","  function convertString(str, tokenType) {","    var output = str;","","    switch (tokenType) {","      case TOKENTYPES.time:","        var parts = str.split(/(:|am|pm)/),","            hour = parts[3] === 'pm' ? parseInt(parts[0],10) + 12 : parts[0],","            min = parts[2].trim();","","        output = (hour.length === 1 ? '0' : '') + hour + \":\" + min;","        break;","","      case TOKENTYPES.rank:","        output = parseInt((/^\\d+/.exec(str))[0],10);","        break;","","      case TOKENTYPES.monthName:","      case TOKENTYPES.dayName:","        output = NAMES[str.substring(0,3)];","        break;","    }","","    return output;","  }","","  return {","","    /**","    * Parses a schedule string.  Returns the schedule, exceptions, and","    * an error position if an error was hit.","    *","    * @param {String} str: The schedule string to parse","    * @api public","    */","    parse: function(str) {","      return parseScheduleExpr(str.toLowerCase());","    }","  };","};"];
_$jscoverage['parse/text.js'][12]++;
later.parse.text = (function () {
  _$jscoverage['parse/text.js'][14]++;
  var recur = later.parse.recur, pos = 0, input = "", error;
  _$jscoverage['parse/text.js'][20]++;
  var TOKENTYPES = {eof: /^$/, rank: /^((\d\d\d\d)|([2-5]?1(st)?|[2-5]?2(nd)?|[2-5]?3(rd)?|(0|[1-5]?[4-9]|[1-5]0|1[1-3])(th)?))\b/, time: /^((([0]?[1-9]|1[0-2]):[0-5]\d(\s)?(am|pm))|(([0]?\d|1\d|2[0-3]):[0-5]\d))\b/, dayName: /^((sun|mon|tue(s)?|wed(nes)?|thu(r(s)?)?|fri|sat(ur)?)(day)?)\b/, monthName: /^(jan(uary)?|feb(ruary)?|ma((r(ch)?)?|y)|apr(il)?|ju(ly|ne)|aug(ust)?|oct(ober)?|(sept|nov|dec)(ember)?)\b/, yearIndex: /^(\d\d\d\d)\b/, every: /^every\b/, after: /^after\b/, second: /^(s|sec(ond)?(s)?)\b/, minute: /^(m|min(ute)?(s)?)\b/, hour: /^(h|hour(s)?)\b/, day: /^(day(s)?( of the month)?)\b/, dayInstance: /^day instance\b/, dayOfWeek: /^day(s)? of the week\b/, dayOfYear: /^day(s)? of the year\b/, weekOfYear: /^week(s)?( of the year)?\b/, weekOfMonth: /^week(s)? of the month\b/, weekday: /^weekday\b/, weekend: /^weekend\b/, month: /^month(s)?\b/, year: /^year(s)?\b/, between: /^between (the)?\b/, start: /^(start(ing)? (at|on( the)?)?)\b/, at: /^(at|@)\b/, and: /^(,|and\b)/, except: /^(except\b)/, also: /(also)\b/, first: /^(first)\b/, last: /^last\b/, "in": /^in\b/, of: /^of\b/, onthe: /^on the\b/, on: /^on\b/, through: /(-|^(to|through)\b)/};
  _$jscoverage['parse/text.js'][58]++;
  var NAMES = {jan: 1, feb: 2, mar: 3, apr: 4, may: 5, jun: 6, jul: 7, aug: 8, sep: 9, oct: 10, nov: 11, dec: 12, sun: 1, mon: 2, tue: 3, wed: 4, thu: 5, fri: 6, sat: 7, "1st": 1, fir: 1, "2nd": 2, sec: 2, "3rd": 3, thi: 3, "4th": 4, "for": 4};
  _$jscoverage['parse/text.js'][72]++;
  function t(start, end, text, type) {
    _$jscoverage['parse/text.js'][73]++;
    return ({startPos: start, endPos: end, text: text, type: type});
}
  _$jscoverage['parse/text.js'][82]++;
  function peek(expected) {
    _$jscoverage['parse/text.js'][83]++;
    var scanTokens = ((expected instanceof Array)? expected: [expected]), whiteSpace = /\s+/, token, curInput, m, scanToken, start, len;
    _$jscoverage['parse/text.js'][87]++;
    scanTokens.push(whiteSpace);
    _$jscoverage['parse/text.js'][90]++;
    start = pos;
    _$jscoverage['parse/text.js'][91]++;
    while (((! token) || (token.type === whiteSpace))) {
      _$jscoverage['parse/text.js'][92]++;
      len = -1;
      _$jscoverage['parse/text.js'][93]++;
      curInput = input.substring(start);
      _$jscoverage['parse/text.js'][94]++;
      token = t(start, start, input.split(whiteSpace)[0]);
      _$jscoverage['parse/text.js'][96]++;
      var i, length = scanTokens.length;
      _$jscoverage['parse/text.js'][97]++;
      for (i = 0; (i < length); (i++)) {
        _$jscoverage['parse/text.js'][98]++;
        scanToken = scanTokens[i];
        _$jscoverage['parse/text.js'][99]++;
        m = scanToken.exec(curInput);
        _$jscoverage['parse/text.js'][100]++;
        if ((m && (m.index === 0) && (m[0].length > len))) {
          _$jscoverage['parse/text.js'][101]++;
          len = m[0].length;
          _$jscoverage['parse/text.js'][102]++;
          token = t(start, (start + len), curInput.substring(0, len), scanToken);
        }
}
      _$jscoverage['parse/text.js'][107]++;
      if ((token.type === whiteSpace)) {
        _$jscoverage['parse/text.js'][108]++;
        start = token.endPos;
      }
}
    _$jscoverage['parse/text.js'][112]++;
    return token;
}
  _$jscoverage['parse/text.js'][120]++;
  function scan(expectedToken) {
    _$jscoverage['parse/text.js'][121]++;
    var token = peek(expectedToken);
    _$jscoverage['parse/text.js'][122]++;
    pos = token.endPos;
    _$jscoverage['parse/text.js'][123]++;
    return token;
}
  _$jscoverage['parse/text.js'][132]++;
  function parseThroughExpr(tokenType) {
    _$jscoverage['parse/text.js'][133]++;
    var start = (+ parseTokenValue(tokenType)), end = (checkAndParse(TOKENTYPES.through)? (+ parseTokenValue(tokenType)): start), nums = [];
    _$jscoverage['parse/text.js'][137]++;
    for (var i = start; (i <= end); (i++)) {
      _$jscoverage['parse/text.js'][138]++;
      nums.push(i);
}
    _$jscoverage['parse/text.js'][141]++;
    return nums;
}
  _$jscoverage['parse/text.js'][150]++;
  function parseRanges(tokenType) {
    _$jscoverage['parse/text.js'][151]++;
    var nums = parseThroughExpr(tokenType);
    _$jscoverage['parse/text.js'][152]++;
    while (checkAndParse(TOKENTYPES.and)) {
      _$jscoverage['parse/text.js'][153]++;
      nums = nums.concat(parseThroughExpr(tokenType));
}
    _$jscoverage['parse/text.js'][155]++;
    return nums;
}
  _$jscoverage['parse/text.js'][163]++;
  function parseEvery(r) {
    _$jscoverage['parse/text.js'][164]++;
    var num, period, start, end;
    _$jscoverage['parse/text.js'][166]++;
    if (checkAndParse(TOKENTYPES.weekend)) {
      _$jscoverage['parse/text.js'][167]++;
      r.on(NAMES.sun, NAMES.sat).dayOfWeek();
    }
    else {
      _$jscoverage['parse/text.js'][169]++;
      if (checkAndParse(TOKENTYPES.weekday)) {
        _$jscoverage['parse/text.js'][170]++;
        r.on(NAMES.mon, NAMES.tue, NAMES.wed, NAMES.thu, NAMES.fri).dayOfWeek();
      }
      else {
        _$jscoverage['parse/text.js'][173]++;
        num = parseTokenValue(TOKENTYPES.rank);
        _$jscoverage['parse/text.js'][174]++;
        r.every(num);
        _$jscoverage['parse/text.js'][175]++;
        period = parseTimePeriod(r);
        _$jscoverage['parse/text.js'][177]++;
        if (checkAndParse(TOKENTYPES.start)) {
          _$jscoverage['parse/text.js'][178]++;
          num = parseTokenValue(TOKENTYPES.rank);
          _$jscoverage['parse/text.js'][179]++;
          r.startingOn(num);
          _$jscoverage['parse/text.js'][180]++;
          parseToken(period.type);
        }
        else {
          _$jscoverage['parse/text.js'][182]++;
          if (checkAndParse(TOKENTYPES.between)) {
            _$jscoverage['parse/text.js'][183]++;
            start = parseTokenValue(TOKENTYPES.rank);
            _$jscoverage['parse/text.js'][184]++;
            if (checkAndParse(TOKENTYPES.and)) {
              _$jscoverage['parse/text.js'][185]++;
              end = parseTokenValue(TOKENTYPES.rank);
              _$jscoverage['parse/text.js'][186]++;
              r.between(start, end);
            }
          }
        }
      }
    }
}
  _$jscoverage['parse/text.js'][197]++;
  function parseOnThe(r) {
    _$jscoverage['parse/text.js'][198]++;
    if (checkAndParse(TOKENTYPES.first)) {
      _$jscoverage['parse/text.js'][199]++;
      r.first();
    }
    else {
      _$jscoverage['parse/text.js'][201]++;
      if (checkAndParse(TOKENTYPES.last)) {
        _$jscoverage['parse/text.js'][202]++;
        r.last();
      }
      else {
        _$jscoverage['parse/text.js'][205]++;
        r.on(parseRanges(TOKENTYPES.rank));
      }
    }
    _$jscoverage['parse/text.js'][208]++;
    parseTimePeriod(r);
}
  _$jscoverage['parse/text.js'][219]++;
  function parseScheduleExpr(str) {
    _$jscoverage['parse/text.js'][220]++;
    pos = 0;
    _$jscoverage['parse/text.js'][221]++;
    input = str;
    _$jscoverage['parse/text.js'][222]++;
    error = -1;
    _$jscoverage['parse/text.js'][224]++;
    var r = recur();
    _$jscoverage['parse/text.js'][225]++;
    while (((pos < input.length) && (error < 0))) {
      _$jscoverage['parse/text.js'][227]++;
      var token = parseToken([TOKENTYPES.every, TOKENTYPES.after, TOKENTYPES.onthe, TOKENTYPES.on, TOKENTYPES.of, TOKENTYPES["in"], TOKENTYPES.at, TOKENTYPES.and, TOKENTYPES.except, TOKENTYPES.also]);
      _$jscoverage['parse/text.js'][232]++;
      switch (token.type) {
      case TOKENTYPES.every:
        _$jscoverage['parse/text.js'][234]++;
        parseEvery(r);
        _$jscoverage['parse/text.js'][235]++;
        break;
      case TOKENTYPES.after:
        _$jscoverage['parse/text.js'][237]++;
        r.after(parseTokenValue(TOKENTYPES.rank));
        _$jscoverage['parse/text.js'][238]++;
        parseTimePeriod(r);
        _$jscoverage['parse/text.js'][239]++;
        break;
      case TOKENTYPES.onthe:
        _$jscoverage['parse/text.js'][241]++;
        parseOnThe(r);
        _$jscoverage['parse/text.js'][242]++;
        break;
      case TOKENTYPES.on:
        _$jscoverage['parse/text.js'][244]++;
        r.on(parseRanges(TOKENTYPES.dayName)).dayOfWeek();
        _$jscoverage['parse/text.js'][245]++;
        break;
      case TOKENTYPES.of:
        _$jscoverage['parse/text.js'][247]++;
        r.on(parseRanges(TOKENTYPES.monthName)).month();
        _$jscoverage['parse/text.js'][248]++;
        break;
      case TOKENTYPES["in"]:
        _$jscoverage['parse/text.js'][250]++;
        r.on(parseRanges(TOKENTYPES.yearIndex)).year();
        _$jscoverage['parse/text.js'][251]++;
        break;
      case TOKENTYPES.at:
        _$jscoverage['parse/text.js'][253]++;
        r.at(parseTokenValue(TOKENTYPES.time));
        _$jscoverage['parse/text.js'][254]++;
        while (checkAndParse(TOKENTYPES.and)) {
          _$jscoverage['parse/text.js'][255]++;
          r.at(parseTokenValue(TOKENTYPES.time));
}
        _$jscoverage['parse/text.js'][257]++;
        break;
      case TOKENTYPES.also:
        _$jscoverage['parse/text.js'][259]++;
        r.and();
        _$jscoverage['parse/text.js'][260]++;
        break;
      case TOKENTYPES.except:
        _$jscoverage['parse/text.js'][262]++;
        r.except();
        _$jscoverage['parse/text.js'][263]++;
        break;
      default:
        _$jscoverage['parse/text.js'][265]++;
        error = pos;
      }
}
    _$jscoverage['parse/text.js'][269]++;
    return ({schedules: r.schedules, exceptions: r.exceptions, error: error});
}
  _$jscoverage['parse/text.js'][278]++;
  function parseTimePeriod(r) {
    _$jscoverage['parse/text.js'][279]++;
    var timePeriod = parseToken([TOKENTYPES.second, TOKENTYPES.minute, TOKENTYPES.hour, TOKENTYPES.dayOfYear, TOKENTYPES.dayOfWeek, TOKENTYPES.dayInstance, TOKENTYPES.day, TOKENTYPES.month, TOKENTYPES.year, TOKENTYPES.weekOfMonth, TOKENTYPES.weekOfYear]);
    _$jscoverage['parse/text.js'][284]++;
    switch (timePeriod.type) {
    case TOKENTYPES.second:
      _$jscoverage['parse/text.js'][286]++;
      r.second();
      _$jscoverage['parse/text.js'][287]++;
      break;
    case TOKENTYPES.minute:
      _$jscoverage['parse/text.js'][289]++;
      r.minute();
      _$jscoverage['parse/text.js'][290]++;
      break;
    case TOKENTYPES.hour:
      _$jscoverage['parse/text.js'][292]++;
      r.hour();
      _$jscoverage['parse/text.js'][293]++;
      break;
    case TOKENTYPES.dayOfYear:
      _$jscoverage['parse/text.js'][295]++;
      r.dayOfYear();
      _$jscoverage['parse/text.js'][296]++;
      break;
    case TOKENTYPES.dayOfWeek:
      _$jscoverage['parse/text.js'][298]++;
      r.dayOfWeek();
      _$jscoverage['parse/text.js'][299]++;
      break;
    case TOKENTYPES.dayInstance:
      _$jscoverage['parse/text.js'][301]++;
      r.dayOfWeekCount();
      _$jscoverage['parse/text.js'][302]++;
      break;
    case TOKENTYPES.day:
      _$jscoverage['parse/text.js'][304]++;
      r.dayOfMonth();
      _$jscoverage['parse/text.js'][305]++;
      break;
    case TOKENTYPES.weekOfMonth:
      _$jscoverage['parse/text.js'][307]++;
      r.weekOfMonth();
      _$jscoverage['parse/text.js'][308]++;
      break;
    case TOKENTYPES.weekOfYear:
      _$jscoverage['parse/text.js'][310]++;
      r.weekOfYear();
      _$jscoverage['parse/text.js'][311]++;
      break;
    case TOKENTYPES.month:
      _$jscoverage['parse/text.js'][313]++;
      r.month();
      _$jscoverage['parse/text.js'][314]++;
      break;
    case TOKENTYPES.year:
      _$jscoverage['parse/text.js'][316]++;
      r.year();
      _$jscoverage['parse/text.js'][317]++;
      break;
    default:
      _$jscoverage['parse/text.js'][319]++;
      error = pos;
    }
    _$jscoverage['parse/text.js'][322]++;
    return timePeriod;
}
  _$jscoverage['parse/text.js'][331]++;
  function checkAndParse(tokenType) {
    _$jscoverage['parse/text.js'][332]++;
    var found = (peek(tokenType).type === tokenType);
    _$jscoverage['parse/text.js'][333]++;
    if (found) {
      _$jscoverage['parse/text.js'][334]++;
      scan(tokenType);
    }
    _$jscoverage['parse/text.js'][336]++;
    return found;
}
  _$jscoverage['parse/text.js'][344]++;
  function parseToken(tokenType) {
    _$jscoverage['parse/text.js'][345]++;
    var t = scan(tokenType);
    _$jscoverage['parse/text.js'][346]++;
    if (t.type) {
      _$jscoverage['parse/text.js'][347]++;
      t.text = convertString(t.text, tokenType);
    }
    else {
      _$jscoverage['parse/text.js'][350]++;
      error = pos;
    }
    _$jscoverage['parse/text.js'][352]++;
    return t;
}
  _$jscoverage['parse/text.js'][360]++;
  function parseTokenValue(tokenType) {
    _$jscoverage['parse/text.js'][361]++;
    return parseToken(tokenType).text;
}
  _$jscoverage['parse/text.js'][371]++;
  function convertString(str, tokenType) {
    _$jscoverage['parse/text.js'][372]++;
    var output = str;
    _$jscoverage['parse/text.js'][374]++;
    switch (tokenType) {
    case TOKENTYPES.time:
      _$jscoverage['parse/text.js'][376]++;
      var parts = str.split(/(:|am|pm)/), hour = ((parts[3] === "pm")? (parseInt(parts[0], 10) + 12): parts[0]), min = parts[2].trim();
      _$jscoverage['parse/text.js'][380]++;
      output = (((hour.length === 1)? "0": "") + hour + ":" + min);
      _$jscoverage['parse/text.js'][381]++;
      break;
    case TOKENTYPES.rank:
      _$jscoverage['parse/text.js'][384]++;
      output = parseInt(/^\d+/.exec(str)[0], 10);
      _$jscoverage['parse/text.js'][385]++;
      break;
    case TOKENTYPES.monthName:
    case TOKENTYPES.dayName:
      _$jscoverage['parse/text.js'][389]++;
      output = NAMES[str.substring(0, 3)];
      _$jscoverage['parse/text.js'][390]++;
      break;
    }
    _$jscoverage['parse/text.js'][393]++;
    return output;
}
  _$jscoverage['parse/text.js'][396]++;
  return ({parse: (function (str) {
  _$jscoverage['parse/text.js'][406]++;
  return parseScheduleExpr(str.toLowerCase());
})});
});

    return later;
})();
